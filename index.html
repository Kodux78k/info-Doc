<!DOCTYPE html>
<html lang="pt-BR">
<head><meta charset="utf-8">
 
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Portal ‚Äî Livro Vivo</title>
<meta name="theme-color" content="#0a0e18" />
<link rel="manifest" href="manifest.webmanifest" />
<link rel="icon" href="icons/icon-d0x.PNG" />
<link rel="apple-touch-icon" href="icons/icon-d0x.PNG" />
<link rel="preconnect" href="https://unpkg.com" crossorigin>
<meta name="color-scheme" content="dark"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">
<style>
:root{--grad-a:#ff00ff;--grad-b:#00ffff;--bg:#07080c;--bg2:#0b0e16;--panel:#0e1220;--ink:#e8ecf6;--muted:#a2acc5;--gold:#f7d774;--cyan:#67e6ff;--blur:14px;--radius:18px;--maxw:900px;--pad:20px;--ring:0 0 0 1px rgba(255,255,255,.08) inset,0 0 40px rgba(102,255,255,.08);--glow:0 10px 30px rgba(0,0,0,.35),0 0 80px rgba(0,255,255,.08)}
.theme-gold{--grad-a:#ffd54a;--grad-b:#ff8a00;--cyan:#ffd97a;--gold:#ffe08a;--panel:#12100b;--bg:#0a0906;--ink:#fff6db;--muted:#d3c6a2}
.theme-thermal{--grad-a:#ff7ae6;--grad-b:#ff7a00;--cyan:#ffc29d;--gold:#ffc6f3;--panel:#160e15;--bg:#0b0710;--ink:#ffeefe;--muted:#d4bcd2}
*{box-sizing:border-box}html,body{height:100%;margin:0}body{background:var(--bg);color:var(--ink);font:400 16px/1.65 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow-x:hidden}
.nebula{position:fixed;inset:0;z-index:-1;pointer-events:none;background:radial-gradient(1200px 800px at 20% -10%, color-mix(in oklab, var(--grad-a) 20%, transparent), transparent 60%),radial-gradient(900px 700px at 110% 10%, color-mix(in oklab, var(--grad-b) 18%, transparent), transparent 50%)}
.wrap{max-width:var(--maxw);margin:0 auto;padding:calc(12px + env(safe-area-inset-top)) var(--pad) calc(100px + env(safe-area-inset-bottom))}
details.acc{border-radius:16px;background:linear-gradient(0deg,rgba(255,255,255,.02),rgba(255,255,255,.03)),var(--panel);border:1px solid rgba(255,255,255,.08);box-shadow:var(--glow);margin:14px 0}
summary{display:flex;align-items:center;gap:10px;padding:14px 16px;cursor:pointer}summary::-webkit-details-marker{display:none}.chev{width:10px;height:10px;border-right:2px solid var(--ink);border-bottom:2px solid var(--ink);transform:rotate(-45deg);transition:.2s}details[open] .chev{transform:rotate(45deg)}.sec{padding:0 16px 16px}
blockquote,.equation,.blockcoach{border-radius:12px;padding:12px 14px;margin:12px 0;position:relative}.copy-hint{position:absolute;right:10px;top:10px;font-size:.8rem;opacity:.6}blockquote{border-left:3px solid var(--cyan);background:rgba(255,255,255,.03)}.equation{background:rgba(255,255,255,.03);font-family:ui-monospace,monospace}
#fab{position:fixed;right:14px;bottom:14px;z-index:100;display:flex;flex-direction:column;gap:10px}.fab-btn{width:56px;height:56px;border-radius:50%;border:1px solid rgba(255,255,255,.14);background:linear-gradient(42deg,var(--grad-a),var(--grad-b));color:#000;font-weight:900;font-size:1.2rem;cursor:pointer;box-shadow:var(--ring)}.menu{display:none;position:absolute;right:62px;bottom:0;flex-direction:column;gap:8px}#fab.open .menu{display:flex}.btn{border:1px solid rgba(255,255,255,.14);border-radius:10px;padding:.55rem .8rem;background:linear-gradient(42deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--ink);cursor:pointer}
#read-exit{position:fixed;top:12px;left:12px;z-index:120;display:none;padding:8px 10px;border-radius:10px;background:linear-gradient(42deg,var(--grad-a),var(--grad-b));color:#000;border:1px solid rgba(255,255,255,.18);cursor:pointer;box-shadow:var(--ring)}.reading #read-exit{display:block}
#imp{position:fixed;inset:0;display:none;z-index:50;background:rgba(0,0,0,.5);backdrop-filter:blur(10px)}.panel{position:absolute;bottom:0;left:0;right:0;background:var(--panel);border-top:1px solid rgba(255,255,255,.1);border-radius:20px 20px 0 0;padding:16px}
.tabs{display:flex;gap:10px;margin-bottom:10px}.tab{flex:1;text-align:center;padding:8px;border-radius:8px;background:rgba(255,255,255,.08);cursor:pointer}.tab.active{background:linear-gradient(42deg,var(--grad-a),var(--grad-b));color:#000;font-weight:700}.tab-content{display:none}.tab-content.active{display:block}
textarea{width:100%;height:160px;border-radius:10px;border:1px solid rgba(255,255,255,.1);background:#0a0e18;color:var(--ink);padding:12px}
#toasts{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);display:flex;flex-direction:column;gap:6px;z-index:99}.toast{background:rgba(0,0,0,.7);color:#fff;padding:10px 14px;border-radius:10px;animation:fade 2s forwards}
@page{size:A4;margin:18mm}@media print{#fab,#imp,#toasts,.copy-hint,#read-exit{display:none!important}body{background:#fff;color:#000}details.acc{background:#fff;border-color:#ddd;box-shadow:none}}
.reading body{font-size:18px;line-height:1.85}.reading .wrap{max-width:780px;padding:20px 18px}.reading #fab,.reading #imp,.reading #toasts,.reading .copy-hint{display:none!important}


/* === Markdown+ blocks === */
pre.md-code{position:relative;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);
  padding:12px 14px;border-radius:12px;overflow:auto;font:500 13px/1.5 ui-monospace,SFMono-Regular,Consolas,monospace;margin:12px 0}
pre.md-code .copy-hint{position:absolute;right:10px;top:10px;font-size:.8rem;opacity:.6}
code.code-inline{background:rgba(255,255,255,.06);padding:.1rem .3rem;border-radius:6px}

table.md-table{width:100%;border-collapse:collapse;margin:12px 0;border-radius:12px;overflow:hidden}
table.md-table th,table.md-table td{border:1px solid rgba(255,255,255,.12);padding:8px 10px;vertical-align:top}
table.md-table th{background:rgba(255,255,255,.06);font-weight:700}

ul.md-list,ol.md-list{padding-left:1.1rem;margin:10px 0}
ul.md-task{list-style:none;padding-left:0}
ul.md-task li{display:flex;gap:.5rem;align-items:flex-start;margin:6px 0}
ul.md-task input[type=checkbox]{accent-color:var(--cyan);pointer-events:none}

.callout{border-left:3px solid var(--cyan);background:rgba(255,255,255,.03);border-radius:12px;padding:12px;margin:12px 0}
.callout.warn{border-color:#ffda7a}
.callout.tip{border-color:#9ff7b9}

.hr{height:1px;border:0;background:linear-gradient(90deg,transparent,rgba(255,255,255,.2),transparent);margin:16px 0}
img.md-img{max-width:100%;display:block;margin:10px auto;border-radius:12px}
.kbd{font:600 12px ui-monospace,monospace;background:rgba(255,255,255,.06);padding:.1rem .35rem;border-radius:6px;border:1px solid rgba(255,255,255,.12)}


/* === PATCH EQ/QUOTE/FN === */
.equation{white-space:pre-wrap}
blockquote.bq{border-left:3px solid var(--cyan);background:rgba(255,255,255,.03);
  border-radius:12px;padding:10px 12px;margin:12px 0;position:relative}
blockquote.bq .bq-line{margin:6px 0}
blockquote.bq-l2{border-left-width:6px;opacity:.96}
blockquote.bq-l3{border-left-width:9px;opacity:.92}
.callout.note{border-left:3px solid #7ad0ff}
.callout.aside{border-left:3px solid var(--muted)}
.callout.success{border-left:3px solid #9ff7b9}
.callout.danger{border-left:3px solid #ff9f9f}
.callout.question{border-left:3px solid #b7a6ff}


/* === Welcome panel & inputs === */
.welcome{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.03);
  border-radius:14px;padding:12px;margin:12px 0}
.welcome .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.field{width:min(360px,100%);border:1px solid rgba(255,255,255,.12);background:#0a0e18;
  color:var(--ink);border-radius:10px;padding:8px 10px}
.small{font-size:.9rem;color:var(--muted)}
.equation{white-space:pre-wrap}


/* === Master Block (Topo do Documento) === */
.master-block{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.03);
  border-radius:12px;padding:12px;margin:12px 0}
.master-block .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.master-block .title{flex:1;min-width:200px;border:1px solid rgba(255,255,255,.12);
  background:#0a0e18;color:var(--ink);border-radius:10px;padding:8px 10px}

/* === Stacks (Home) === */
.stack-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px;margin-top:10px}
.stack-card{border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px;background:rgba(255,255,255,.03)}
.stack-card h4{margin:0 0 6px 0}
.stack-card .meta{font-size:.85rem;color:var(--muted);margin-bottom:8px}

</style>
<style id="ORB2D_CSS_V1">
:root{
  --orb-a: var(--grad-a);
  --orb-b: var(--grad-b);
  --orb-size: 64px;
  --orb-blur: 18px;
  --orb-ring: 0 0 0 1px rgba(255,255,255,.12) inset, 0 10px 30px rgba(0,0,0,.35);
}
#fab{ position:fixed; right:14px; bottom:14px; z-index:120; display:flex; flex-direction:column; gap:10px; }
#fab .fab-btn{ display:none !important; }
#orb2d{ width:var(--orb-size); height:var(--orb-size); border-radius:999px; border:1px solid rgba(255,255,255,.14);
  position:relative; cursor:pointer; box-shadow: var(--orb-ring);
  background:
    radial-gradient(120% 120% at 30% 20%, color-mix(in oklab, var(--orb-a) 65%, transparent), transparent 60%),
    radial-gradient(120% 120% at 80% 70%, color-mix(in oklab, var(--orb-b) 60%, transparent), transparent 50%),
    conic-gradient(from 0deg, color-mix(in oklab, var(--orb-b) 45%, transparent), transparent 40%, color-mix(in oklab, var(--orb-a) 45%, transparent));
  filter: saturate(1.1);
  animation: orb-spin 10s linear infinite, orb-breath 3.6s ease-in-out infinite;
  outline: none; -webkit-tap-highlight-color: transparent;
}
#orb2d::before{ /* inner glow */
  content:''; position:absolute; inset:6px; border-radius:inherit;
  background: radial-gradient(80% 80% at 50% 40%, rgba(255,255,255,.35), transparent 60%);
  mix-blend-mode: screen; pointer-events:none;
}
#orb2d::after{ /* rim highlight */
  content:''; position:absolute; inset:0; border-radius:inherit;
  box-shadow: inset 0 0 30px rgba(255,255,255,.12);
  pointer-events:none;
}
#fab.open #orb2d{ animation-duration: 6s; box-shadow: 0 0 0 1px rgba(255,255,255,.18) inset, 0 14px 40px rgba(0,0,0,.45), 0 0 80px color-mix(in oklab, var(--orb-b) 35%, transparent); }
#orb-picker{ position:absolute; right:72px; bottom:0; display:none; flex-direction:column; gap:6px; }
#fab.show-picker #orb-picker{ display:flex; }
#orb-picker .chip{ border:1px solid rgba(255,255,255,.14); border-radius:10px; padding:.45rem .7rem;
  background:linear-gradient(42deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); color:var(--ink); }
@keyframes orb-spin{ to { transform: rotate(360deg); } }
@keyframes orb-breath{ 0%,100% { filter:saturate(1) blur(0px); } 50% { filter:saturate(1.2) blur(1px); } }
</style>




<style id="FAB_BTN_TWEAKS_V3">
:root{ --fab-btn-opacity: .92; --fab-btn-bg: rgba(255,255,255,.10); --fab-btn-brd: rgba(255,255,255,.20); }
#fab .menu{ display:none; position:absolute; right:72px; bottom:0; gap:8px; flex-direction:column; }
#fab.open .menu{ display:flex; }
#fab .menu .btn, #fab .menu button, #fab .menu a{
  opacity: var(--fab-btn-opacity);
  border:1px solid var(--fab-btn-brd);
  background: linear-gradient(42deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
  color: var(--ink, #e8ecf6);
  border-radius: 12px;
  padding: .55rem .75rem;
  font: 600 14px/1.1 system-ui, sans-serif;
  box-shadow: 0 6px 20px rgba(0,0,0,.25);
}
#fab .menu .btn:active { transform: translateY(1px); opacity: 1; }
</style>

<!-- KOBLLUX :: HIDE OLD TTS -->
<style id="KOB_TTS_HIDE_OLD">
  .kob-tts-panel:not(.kob-tts-dock),
  [data-tts-panel-old],
  #ttsPanelOld,
  .tts-panel,
  [id*="tts-panel-old"] { display:none !important; }
</style>

<!-- KOBLLUX :: TTS v32 ‚Äî Dock CSS (√≠cones 29px + status compacto + highlight) -->
<style id="KOB_TTS_DOCK_V32">
  :root{
    --tts-left: 8px;         /* posi√ß√£o lembrada (drag) */
    --tts-bottom: 240px;     /* idem */
  }
  .kob-tts-dock{
    position:fixed; z-index:9999; left:var(--tts-left);
    bottom:calc(var(--tts-bottom) + env(safe-area-inset-bottom,0px));
    display:flex; flex-direction:column; gap:8px;
    padding:6px; border-radius:14px;
    background:rgba(15,18,28,.38);
    border:1px solid rgba(255,255,255,.12);
    -webkit-backdrop-filter:blur(10px) saturate(1.1);
    backdrop-filter:blur(10px) saturate(1.1);
    box-shadow:0 12px 26px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05);
    touch-action:none; cursor:grab;
  }
  .kob-tts-dock.is-drag{ cursor:grabbing; }
  .kob-tts-dock button{
    width:29px; height:29px; border-radius:9px;
    display:grid; place-items:center;
    font-size:16px; line-height:1; color:rgba(255,255,255,.85);
    border:1px solid rgba(255,255,255,.18);
    background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.02));
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.06);
    transition:transform .14s ease, box-shadow .14s ease, color .14s ease;
  }
  .kob-tts-dock button:hover{ transform:translateY(-1px); color:#fff; }
  .kob-tts-dock button[aria-pressed="true"]{
    outline:2px solid color-mix(in srgb, #00e28b 70%, #67e6ff 30%);
    box-shadow:0 8px 20px rgba(0,0,0,.35), 0 0 18px -2px rgba(103,230,255,.8);
  }
  #tts-status{
    margin-top:.1rem; font-size:11px; color:#eaf6ff; max-width:140px;
    display:block; white-space:normal; word-break:break-word;
  }
  [data-tts-current]{
    outline:2px dashed #00e28b;
    background:rgba(0,226,139,.06);
    border-radius:8px;
    transition:background .2s ease, outline .2s ease;
  }
  #kob-tts-outline{
    position:absolute; display:none; pointer-events:none; z-index:9998;
    border:2px dashed #00e28b; border-radius:10px;
  }
  @media print{ .kob-tts-dock,#kob-tts-outline{ display:none !important; } }
</style>


<style id="INFODOXY_OVERRIDE_V1">
:root{
  --grad-a:#78e3ff; --grad-b:#b978ff;
  --bg:#070b14; --panel:#0c1120;
  --ink:#eaf6ff; --muted:#9db0cc;
  --glow-in:#7af9ff; --glow-out:#b978ff;
  --radius:18px; --blur:18px;
}
body{
  background:radial-gradient(900px 700px at 50% 10%,rgba(123,243,255,.06),transparent 80%),
             radial-gradient(600px 600px at 70% 100%,rgba(180,120,255,.04),transparent 80%),
             var(--bg);
  color:var(--ink);
  font-family:"Inter","SF Pro",system-ui;
}
details.acc{
  background:rgba(255,255,255,.03);
  border:1px solid rgba(255,255,255,.1);
  box-shadow:0 0 20px rgba(120,240,255,.04) inset,0 0 60px rgba(180,120,255,.05);
  border-radius:var(--radius);
  transition:.25s all ease;
}
details.acc:hover{box-shadow:0 0 25px rgba(120,240,255,.08),0 0 80px rgba(180,120,255,.1);}
summary h2{color:var(--ink);text-shadow:0 0 12px rgba(120,240,255,.4);}
.btn{
  border:1px solid rgba(255,255,255,.15);
  background:linear-gradient(45deg,rgba(120,240,255,.15),rgba(180,120,255,.12));
  border-radius:12px;color:var(--ink);
  backdrop-filter:blur(8px);
  box-shadow:0 0 20px rgba(120,240,255,.15);
  transition:.25s ease;
}
.btn:hover{background:linear-gradient(45deg,rgba(120,240,255,.25),rgba(180,120,255,.2));}
#orb2d{
  background:radial-gradient(120% 120% at 30% 30%,rgba(120,240,255,.6),transparent 70%),
             radial-gradient(120% 120% at 70% 70%,rgba(180,120,255,.5),transparent 70%);
  box-shadow:0 0 25px rgba(120,240,255,.4),0 0 80px rgba(180,120,255,.2);
  animation:orb-spin 10s linear infinite,orb-breath 3.6s ease-in-out infinite;
}
#fab .menu .btn{
  background:linear-gradient(42deg,rgba(120,240,255,.15),rgba(180,120,255,.12));
  border:1px solid rgba(255,255,255,.15);
  color:var(--ink);
  border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,.25);
}
.toast{
  background:rgba(10,15,30,.8);
  color:var(--ink);
  box-shadow:0 0 18px rgba(120,240,255,.1);
}
img.md-img{border-radius:12px;box-shadow:0 0 25px rgba(120,240,255,.1);}
@keyframes orb-breath{
  0%,100%{filter:saturate(1) brightness(1);}
  50%{filter:saturate(1.3) brightness(1.2);}
}

</style>

<style id="KOB_VOICE_THEME_CSS_PATCH">
  :root{
    /* dura√ß√£o da transi√ß√£o de cor / glow */
    --kob-voice-theme-duration: 520ms;
  }

  /* Quem responde √†s mudan√ßas de tema de voz */
  body,
  .nebula,
  details.acc,
  .btn,
  #fab,
  .kob-tts-dock,
  .kob-tts-panel.is-dock {
    transition:
      background var(--kob-voice-theme-duration) ease,
      box-shadow var(--kob-voice-theme-duration) ease,
      border-color var(--kob-voice-theme-duration) ease,
      color var(--kob-voice-theme-duration) ease;
  }

  /* Opcional: marcador visual do arqu√©tipo atual */
  body[data-voice-arch] .nebula::before{
    content: attr(data-voice-arch);
    position:absolute;
    top:10px; right:14px;
    padding:4px 8px;
    font-size:11px;
    letter-spacing:.08em;
    text-transform:uppercase;
    border-radius:999px;
    background:rgba(0,0,0,.45);
    border:1px solid rgba(255,255,255,.20);
    color:var(--ink);
    backdrop-filter:blur(6px);
    pointer-events:none;
  }
</style>
<!--  --grad-a:#78e3ff; --grad-b:#b978ff; --bg:#070b14; --panel:#0c1120;
  --ink:#eaf6ff; --muted:#9db0cc;
  --glow-in:#7af9ff; --glow-out:#b978ff; !-->

<style id="KOBLLUX_VOICE_THEME_CSS">
:root{
  
  
  --kob-voice-primary:   #78e3ff;
  --kob-voice-secondary: #b978ff;
  --kob-voice-accent:    #ffffff;
  --kob-voice-bg-soft:radial-gradient(900px 700px at 50% 10%,rgba(123,243,255,.06),transparent 80%),
             radial-gradient(600px 600px at 70% 100%,rgba(180,120,255,.04),transparent 80%),
             var(--bg);
  --kob-voice-glow:      0 0 18px rgba(0,216,216,0.55);
}

/* Dock do TTS acompanha a voz atual */
.kob-tts-dock{
  background: var(--kob-voice-bg-soft);
  box-shadow: var(--kob-voice-glow);
  border-radius: 12px;
  backdrop-filter: blur(16px);
  border: 1px solid rgba(255,255,255,0.06);
}

.kob-tts-dock button[data-tts-btn="toggle"]{
  border: 1px solid var(--kob-voice-primary);
  color:  var(--kob-voice-accent);
}

.kob-tts-dock button[data-tts-btn="sel"],
.kob-tts-dock button[data-tts-btn="stop"]{
  border: 1px solid rgba(255,255,255,0.16);
}

/* Se voc√™ marcar algum bloco como "sendo lido" no futuro */
[data-being-read="true"]{
  outline: 1px solid var(--kob-voice-primary);
  background: var(--kob-voice-bg-soft);
}

/* Tema adicional por arqu√©tipo (opcional, pra brincar com o body) */
body[data-voice-arch="kobllux"]{
  --kob-voice-primary:#00d8d8;
  --kob-voice-secondary:#d800d8;
}
body[data-voice-arch="nova"]{
  --kob-voice-primary:#FF6FB5;
  --kob-voice-secondary:#FFD6E8;
}
body[data-voice-arch="kaos"]{
  --kob-voice-primary:#FF5C8A;
  --kob-voice-secondary:#3D000F;
}
body[data-voice-arch="serena"]{
  --kob-voice-primary:#7AD3A8;
  --kob-voice-secondary:#154734;
}
body[data-voice-arch="vitalis"]{
  --kob-voice-primary:#00F5A0;
  --kob-voice-secondary:#00D9F5;
}
body[data-voice-arch="pulse"]{
  --kob-voice-primary:#A259FF;
  --kob-voice-secondary:#2D1B69;
}
body[data-voice-arch="atlas"]{
  --kob-voice-primary:#6CCFF6;
  --kob-voice-secondary:#1B4965;
}
body[data-voice-arch="lumine"]{
  --kob-voice-primary:#FFE066;
  --kob-voice-secondary:#FF9F1C;
}
body[data-voice-arch="rhea"]{
  --kob-voice-primary:#00B894;
  --kob-voice-secondary:#055E55;
}
body[data-voice-arch="solus"]{
  --kob-voice-primary:#4B6584;
  --kob-voice-secondary:#0B1420;
}
body[data-voice-arch="aion"]{
  --kob-voice-primary:#00A8E8;
  --kob-voice-secondary:#001F54;
}
body[data-voice-arch="cooplux"]{
  --kob-voice-primary:#39FFB6;
  --kob-voice-secondary:#00d8d8;
}
body[data-voice-arch="fitlux"]{
  --kob-voice-primary:#FFC857;
  --kob-voice-secondary:#FFE39A;
}
</style>


<!-- KOBLLUX PATCH :: TTS Dock uses theme gradient (Nebula V1) and UTF icons -->
<style id="KOB_PATCH_TTS_DOCK_V1">

.kob-tts-dock{
  background:linear-gradient(
    42deg,
    color-mix(in srgb, var(--grad-a) 18%, transparent),
    color-mix(in srgb, var(--grad-b) 18%, transparent)
  ) !important;
  border:1px solid rgba(255,255,255,.10) !important;
  color:var(--ink) !important;
  box-shadow:0 0 18px rgba(0,0,0,.35) !important;
  backdrop-filter:blur(14px) !important;
}

.kob-tts-dock button{
  background:rgba(0,0,0,.25) !important;
  border:1px solid rgba(255,255,255,.18) !important;
  color:var(--ink) !important;
}

.kob-tts-dock{
  transform: scale(0.85);
  transform-origin: bottom right; /* ou onde voc√™ ancora o dock */
}

</style>


<style id="KOB_PATCH_FECHAR_LEFT">
/* Mover o bot√£o "Fechar" do importer pro canto ESQUERDO */
button.btn[onclick="closeImporter()"]{
  margin-right:auto !important;  /* empurra o bot√£o pra esquerda dentro do flex */
}
</style>

<style id="KOB_PATCH_IFRAME_VIDEO">
  /* Iframes dentro do conte√∫do gerado (root / aninhado) */
  #root iframe,
  .lv-content iframe,
  .nested-view iframe{
    display:block;
    width:100%;
    max-width:100%;
    aspect-ratio:16/9;
    height:auto;
    border:none;
    border-radius:12px;
    margin:12px 0;
    box-shadow:0 12px 32px rgba(0,0,0,.55);
    background:#000;
  }

  /* Se estiver em coluna estreita, deixa um pouco mais compacto */
  @media (max-width: 480px){
    #root iframe,
    .lv-content iframe,
    .nested-view iframe{
      border-radius:10px;
      margin:10px 0;
    }
  }
</style>



</head>
<body>
<div class="nebula"></div>
<button id="read-exit" title="Sair do modo leitura (Esc)">‚Üê Voltar</button>
<div class="wrap" id="root"><details class="acc" open><summary><span class="chev"></span><h2>‚ú® Builder v2 ‚Äì √Åudio + PDF</h2></summary><div class="sec"><p>Abra o painel ‚ÄúAuto‚ÄëGerar‚Äù pelo bot√£o +.</p><div class="demo-cta" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"><button class="btn" data-action="demo">Gerar Demo</button><button class="btn" data-action="importar">Auto‚ÄëGerar</button><button class="btn" data-action="md">Exportar .md</button><button class="btn" data-action="pdf">Imprimir (PDF)</button></div></div></details></div>
<div id="toasts"></div>
<div id="fab"><div class="menu">
    <button class="btn" data-action="home">Home</button>
    <button class="btn" data-action="back">Voltar</button>

    <button class="btn" id="btn-tts" data-action="tts">Voz: Off</button>
    <button class="btn" id="btn-tts-sel" data-action="tts-sel">Ler sele√ß√£o</button>
    <button class="btn" id="btn-tts-stop" data-action="tts-stop">Parar voz</button>
  <button class="btn" data-action="demo">Gerar Demo</button>
    <button class="btn" id="btn-imp" data-action="importar">Auto‚ÄëGerar</button>
  <button class="btn" id="btn-md" data-action="md">Exportar .md</button>
  <button class="btn" id="btn-pdf" data-action="pdf">Imprimir (PDF)</button>
  <button class="btn" id="btn-theme" data-action="theme">Tema: Blue‚Äë1</button>
  <button class="btn" id="btn-reading" data-action="reading">Modo Leitura</button>
</div><button class="fab-btn" id="fab-toggle">Ôºã</button></div>
<div id="imp"><div class="panel">
  <div class="tabs"><div class="tab active" data-tab="text">üìù enviar</div><div class="tab" data-tab="audio">üéôÔ∏è √Åudio‚ÜíTexto</div><div class="tab" data-tab="file">üìÑ Arquivo (PDF/TXT/MD)</div></div>
  <div id="tab-text" class="tab-content active"><textarea id="srcText" placeholder="# PR√ìLOGO
Texto aqui..."></textarea><button class="btn" onclick="autoBuild(document.getElementById('srcText').value)">Gerar Livro</button> <button class="btn" onclick="autoBuildNested(document.getElementById('srcText').value)">Gerar (aninhado)</button> <button class="btn" onclick="pasteSrcText()">Colar</button> <button class="btn" id="btn-converter">Converter</button></div>
  <div id="tab-audio" class="tab-content"><textarea id="audioOutput" placeholder="Transcri√ß√£o aqui..."></textarea><div style="display:flex;gap:8px;margin-top:8px"><button class="btn" id="startRec">üé§ Iniciar</button><button class="btn" id="stopRec">‚èπ Parar</button><button class="btn" onclick="autoBuild(document.getElementById('audioOutput').value)">Usar Transcri√ß√£o</button></div></div>
  <div id="tab-file" class="tab-content"><input type="file" id="fileInput" accept=".pdf,.txt,.md,.rtf, .html"><div id="filePreview" style="margin-top:10px;color:var(--muted);font-size:.9rem"></div></div>
  <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px"><button class="btn" onclick="closeImporter()">Fechar</button></div>
</div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
const $=(q,r=document)=>r.querySelector(q), $$=(q,r=document)=>[...r.querySelectorAll(q)];
const toast=(m)=>{const t=document.createElement('div');t.className='toast';t.textContent=m;document.body.querySelector('#toasts').appendChild(t);setTimeout(()=>t.remove(),2000)}
/* Reading */
function toggleReading(force){const el=document.documentElement; const will = typeof force==='boolean'? force : !el.classList.contains('reading'); el.classList.toggle('reading', will); localStorage.setItem('tl_reading', will?'1':'0'); toast(will?'Modo leitura':'Modo editor');}
document.getElementById('btn-reading').onclick=()=> toggleReading();
document.getElementById('read-exit').onclick=()=> toggleReading(false);
window.addEventListener('keydown',(e)=>{ if(e.key==='Escape') toggleReading(false); if(e.key.toLowerCase()==='r') toggleReading(); if(e.key.toLowerCase()==='t') cycleTheme(); });
/* Theme cycle */
const THEMES=['blue','gold','thermal'];
function setTheme(name){document.documentElement.classList.remove('theme-gold','theme-thermal'); if(name==='gold') document.documentElement.classList.add('theme-gold'); if(name==='thermal') document.documentElement.classList.add('theme-thermal'); localStorage.setItem('tl_theme',name); updateThemeLabel();}
function currentTheme(){return localStorage.getItem('tl_theme')||'blue'} function updateThemeLabel(){const map={blue:'Blue‚Äë1',gold:'Gold',thermal:'Thermal'}; document.getElementById('btn-theme').textContent='Tema: '+map[currentTheme()];}
function cycleTheme(){const i=(THEMES.indexOf(currentTheme())+1)%THEMES.length; setTheme(THEMES[i]); toast('Tema: '+(THEMES[i]==='blue'?'Blue‚Äë1':THEMES[i]==='gold'?'Gold':'Thermal'));}
document.getElementById('btn-theme').onclick=cycleTheme;
/* FAB & Tabs */
document.getElementById('fab-toggle').onclick=()=> document.getElementById('fab').classList.toggle('open');
document.getElementById('btn-imp').onclick=()=> openImporter(); document.getElementById('btn-pdf').onclick=()=> window.print();
function openImporter(){document.getElementById('imp').style.display='block'} function closeImporter(){document.getElementById('imp').style.display='none'}
document.querySelectorAll('.tab').forEach(t=>t.onclick=()=>{document.querySelectorAll('.tab,.tab-content').forEach(e=>e.classList.remove('active'));t.classList.add('active');document.getElementById('tab-'+t.dataset.tab).classList.add('active')})
/* Audio */
let rec;if('webkitSpeechRecognition' in window||'SpeechRecognition' in window){const SR=window.SpeechRecognition||window.webkitSpeechRecognition;rec=new SR();rec.lang='pt-BR';rec.continuous=true;rec.interimResults=true;rec.onresult=(e)=>{let txt='';for(let i=e.resultIndex;i<e.results.length;++i)txt+=e.results[i][0].transcript+(e.results[i].isFinal?'. ':'');document.getElementById('audioOutput').value=txt;};rec.onerror=()=>toast('Erro/Permiss√£o negada');}else toast('STT n√£o suportado.');
document.getElementById('startRec').onclick=()=>{try{rec.start();toast('Gravando...')}catch{toast('N√£o suportado')}};document.getElementById('stopRec').onclick=()=>{try{rec.stop();toast('Parado')}catch{}}
/* Files */

// Removed explicit onclick handler: md button is handled via data-action="md" and window.exportMD
// Legacy duplicate export function retained for reference but unused
function exportMD_deprecated(){
  const parts=[];
  document.querySelectorAll('#root details.acc').forEach(d=>{
    const h=d.querySelector('summary h2'); if(h) parts.push('# '+h.textContent.trim());
    d.querySelectorAll('.sec > *').forEach(node=>{
      if(node.matches('p')) parts.push(node.innerText.trim());
      else if(node.matches('blockquote')) parts.push('> '+node.innerText.replace('Copiar','').trim());
      else if(node.matches('pre.md-code')) parts.push('```\n'+(node.querySelector('code')?.textContent||'')+'\n```');
      else if(node.matches('.equation')) parts.push('$$\n'+node.innerText.replace('Copiar','').trim()+'\n$$');
      else if(node.matches('ul.md-task')){
        node.querySelectorAll('li').forEach(li=>{
          const chk=li.querySelector('input[type=checkbox]'); const t=li.innerText.replace('Copiar','').trim();
          parts.push(`- [${chk&&chk.checked?'x':' '}] ${t}`);
        });
      }else if(node.matches('ul,ol')){
        const isOl=node.matches('ol'); let idx=1;
        node.querySelectorAll('li').forEach(li=>{
          const txt=li.innerText.trim();
          parts.push((isOl? (idx++)+'. ' : '- ')+txt);
        });
      }else if(node.matches('table.md-table')){
        const rows=[...node.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
        if(rows.length){
          parts.push('| '+rows[0].join(' | ')+' |');
          parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
          rows.slice(1).forEach(r=>parts.push('| '+r.join(' | ')+' |'));
        }
      }
    });
  });
  const blob=new Blob([parts.join('\n\n')],{type:'text/markdown'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='export.md'; a.click(); URL.revokeObjectURL(a.href);
  toast('.md exportado');
}

document.getElementById('fileInput').addEventListener('change',async e=>{const f=e.target.files[0];if(!f)return;document.getElementById('filePreview').textContent='Lendo '+f.name+'...'; if(f.name.endsWith('.pdf')){const buf=await f.arrayBuffer();const pdf=await pdfjsLib.getDocument({data:buf}).promise;let txt='';for(let i=1;i<=pdf.numPages;i++){const p=await pdf.getPage(i);const c=await p.getTextContent();txt+=c.items.map(it=>it.str).join(' ')+'\n';}autoBuild(txt);} else {autoBuild(await f.text());}});
/* Builder */


/* Builder (Markdown+ ‚Üí DOM com se√ß√µes) */

function autoBuild(text){
  closeImporter();
  const root = document.getElementById('root');
  root.innerHTML = '';

  const AUTO_SPLIT_EVERY = 14;
  let sectionCount = 0, blocksInSection = 0;
  let sec = null;

  function newSection(title){
    sectionCount++;
    const details = document.createElement('details');
    details.className = 'acc';
    details.open = false;
    const sum = document.createElement('summary');
    sum.innerHTML = '<span class="chev"></span><h2>'+ (title || ('Se√ß√£o '+sectionCount)) +'</h2>';
    const cont = document.createElement('div'); cont.className = 'sec';
    details.append(sum, cont);
    root.appendChild(details);
    blocksInSection = 0;
    return details;
  }
  function ensureSection(titleIfNew){
    if(!sec) sec = newSection(titleIfNew||'Se√ß√£o 1');
    if(blocksInSection >= AUTO_SPLIT_EVERY){
      sec = newSection((getSummary(sec)+' (cont.)'));
    }
    return sec;
  }
  function getSummary(details){
    const h = details.querySelector('summary h2');
    return h ? h.textContent : 'Se√ß√£o';
  }
  function appendToSection(el){ ensureSection(); sec.lastChild.appendChild(el); blocksInSection++; }

  const lines = text.replace(/\r\n?/g,'\n').split('\n');
  let i = 0, inCode = false, codeLang = '', buf = [];
  let inFn = false, fnDepth = 0;

  const flushParagraph = ()=>{
    if(!buf.length) return;
    const content = buf.join(' ').trim();
    if(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{[^]*\}\s*$/.test(content)){
      const div = document.createElement('div');
      div.className = 'equation copyable fn';
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + content;
      div.onclick = ()=>copy(div);
      appendToSection(div);
      buf.length = 0;
      return;
    }
    const p = document.createElement('p');
    p.innerHTML = inlineMD(content);
    appendToSection(p);
    buf.length = 0;
  };

  while(i < lines.length){
    let line = lines[i];
    let norm = line.replace(/[‚Äô‚Äò]/g, "'");

    // cercas de c√≥digo: ``` e '''
    const mFenceOpen = norm.match(/^\s*(?:```|''')([\w-]+)?\s*$/);
    if(!inCode && mFenceOpen){
      flushParagraph();
      inCode = true; codeLang = (mFenceOpen[1]||'').toLowerCase();
      i++; continue;
    }
    if(inCode){
      const mFenceClose = norm.match(/^\s*(?:```|''')+\s*$/);
      if(mFenceClose){
        const pre = document.createElement('pre');
        pre.className = 'md-code copyable';
        const hint = document.createElement('span'); hint.className = 'copy-hint'; hint.textContent = 'Copiar';
        const code = document.createElement('code');
        if(codeLang) code.className = 'lang-'+codeLang;
        code.textContent = buf.join('\n');
        pre.append(hint, code);
        pre.onclick = ()=>copy(pre);
        appendToSection(pre);
        buf.length = 0; inCode = false; codeLang = '';
      }else{
        buf.push(line);
      }
      i++; continue;
    }

    // fun√ß√£o JS multi-linha sem cercas
    if(!inFn){
      const mFnStart = norm.match(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{\s*$/);
      if(mFnStart){
        flushParagraph();
        inFn = true; fnDepth = 1; buf.length = 0; i++; continue;
      }
    }
    if(inFn){
      buf.push(line);
      const open = (line.match(/\{/g) || []).length;
      const close = (line.match(/\}/g) || []).length;
      fnDepth += open - close;
      i++;
      if(fnDepth <= 0){
        const div = document.createElement('div');
        div.className = 'equation copyable fn';
        div.innerHTML = '<span class="copy-hint">Copiar</span>' + escapeHtml(buf.join('\\n'));
        div.onclick = ()=>copy(div);
        appendToSection(div);
        buf.length = 0; inFn = false; fnDepth = 0;
      }
      continue;
    }

    // headings
    const mH = line.match(/^\s*(#{1,6})\s+(.+?)\s*$/);
    if(mH){
      flushParagraph();
      sec = newSection(mH[2].trim());
      i++; continue;
    }

    // hr
    if(/^\s*(?:---|\*\*\*)\s*$/.test(line)){
      flushParagraph();
      const hr = document.createElement('div'); hr.className = 'hr';
      appendToSection(hr); i++; continue;
    }

    // blockquotes aninhados
    if(/^\s*>+/.test(line)){
      flushParagraph();
      const items = [];
      while(i < lines.length && /^\s*>+/.test(lines[i])){
        const m = lines[i].match(/^\s*(>+)\s?(.*)$/);
        items.push({ level: m[1].length, text: m[2] });
        i++;
      }
      const rootBQ = document.createElement('blockquote');
      rootBQ.className = 'bq copyable bq-l1';
      rootBQ.innerHTML = '<span class="copy-hint">Copiar</span>';
      let currentLevel = 1;
      const stack = [rootBQ];
      items.forEach(({level, text})=>{
        while(level > currentLevel){
          const inner = document.createElement('blockquote');
          inner.className = 'bq bq-l' + Math.min(currentLevel+1,3);
          stack[stack.length-1].appendChild(inner);
          stack.push(inner);
          currentLevel++;
        }
        while(level < currentLevel){
          stack.pop();
          currentLevel--;
        }
        const div = document.createElement('div');
        div.className = 'bq-line';
        div.innerHTML = inlineMD(text);
        stack[stack.length-1].appendChild(div);
      });
      rootBQ.onclick = ()=>copy(rootBQ);
      appendToSection(rootBQ);
      continue;
    }

    // callouts estendidos
    const mCallAny = norm.match(/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+(.*)$/i);
    if(mCallAny){
      flushParagraph();
      let kind = 'note';
      if(mCallAny[1] === '::.') kind = 'aside';
      else if(mCallAny[1] === ':') kind = 'note';
      else if(mCallAny[1] === '?') kind = 'question';
      else kind = (mCallAny[2] || 'info').toLowerCase();

      let textBuf = [mCallAny[3]];
      let j = i + 1;
      while (j < lines.length) {
        const nextLine = lines[j];
        const nextNorm = nextLine.replace(/[‚Äô‚Äò]/g, "'").trim();
        // stop if blank line or another callout marker encountered
        if (nextNorm === '') break;
        if (/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+/i.test(nextNorm)) break;
        textBuf.push(nextLine.trim());
        j++;
      }
      i = j;
      const div = document.createElement('div');
      div.className = 'callout copyable ' + kind;
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + inlineMD(textBuf.join(' '));
      div.onclick = ()=>copy(div);
      appendToSection(div);
      continue;
    }

    // math $$ ‚Ä¶ $$
    if(/^\s*\$\$\s*$/.test(line)){
      flushParagraph(); i++;
      let math = '';
      while(i<lines.length && !/^\s*\$\$\s*$/.test(lines[i])){ math += lines[i++] + '\\n'; }
      const eq = document.createElement('div');
      eq.className = 'equation copyable';
      eq.innerHTML = '<span class="copy-hint">Copiar</span>'+ escapeHtml(math.trim());
      eq.onclick = ()=>copy(eq);
      appendToSection(eq);
      if(i<lines.length) i++;
      continue;
    }

    // table
    if(/^\s*\|.*\|\s*$/.test(line)){
      flushParagraph();
      let rows = [ line ];
      while(i+1<lines.length && /^\s*\|.*\|\s*$/.test(lines[i+1])){ rows.push(lines[++i]); }
      const tbl = document.createElement('table'); tbl.className='md-table';
      rows.forEach((r,idx)=>{
        const tr = document.createElement('tr');
        const cells = r.trim().slice(1,-1).split('|').map(c=>c.trim());
        const isSep = (idx===1 && cells.every(x=>/^:?-{3,}:?$/.test(x)));
        if(isSep) return;
        cells.forEach(c=>{
          const cell = document.createElement((idx===0)?'th':'td');
          cell.innerHTML = inlineMD(c);
          tr.appendChild(cell);
        });
        tbl.appendChild(tr);
      });
      appendToSection(tbl); i++; continue;
    }

    // listas
    const mLi = line.match(/^\s*(?:([-*+])\s+|\d+\.\s+)(.+)$/);
    if(mLi){
      flushParagraph();
      const ordered = /^\s*\d+\.\s+/.test(line);
      const list = document.createElement(ordered?'ol':'ul');
      list.className = 'md-list';
      while(i<lines.length){
        const l = lines[i];
        if(!/^\s*(?:[-*+]\s+|\d+\.\s+)/.test(l)) break;
        const raw = l.replace(/^\s*(?:[-*+]\s+|\d+\.\s+)/,'');
        const task = raw.match(/^\s*\[( |x|X)\]\s*(.*)$/);
        const li = document.createElement('li');
        li.className = 'md-li';
        if(task){
          if(!list.classList.contains('md-task')) list.classList.add('md-task');
          const box = document.createElement('input'); box.type='checkbox'; box.checked = /x/i.test(task[1]); box.disabled = true;
          const span = document.createElement('span'); span.innerHTML = inlineMD(task[2]);
          li.append(box, span);
        }else{
          li.innerHTML = inlineMD(raw);
        }
        list.appendChild(li); i++;
      }
      appendToSection(list); continue;
    }

    // par√°grafos
    if(line.trim()===''){ flushParagraph(); i++; continue; }
    buf.push(line.trim()); i++;
  }
  flushParagraph();
  toast('Livro gerado!');
}


/* ===== Helpers p/ Markdown inline & util ===== */
function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function autoLink(url){
  try{ const u = new URL(url); return `<a href="${u.href}" target="_blank" rel="noopener">${u.href}</a>`; }catch{return url;}
}

function inlineMD(s){
  s = escapeHtml(s);
  // imagens ![alt](src)
  s = s.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (_,a,src)=>`<img class="md-img" alt="${a}" src="${src}">`);
  // links [txt](url)
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_,t,href)=>`<a href="${href}" target="_blank" rel="noopener">${t}</a>`);
  // inline code
  s = s.replace(/`([^`]+)`/g, (_,c)=> `<code class="code-inline">${c}</code>`);
  // strong + em
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/(^|[^*])\*([^*]+)\*(?!\*)/g, '$1<em>$2</em>');
  // strike
  s = s.replace(/~~([^~]+)~~/g, '<del>$1</del>');
  // autolink
  s = s.replace(/\bhttps?:\/\/[^\s)]+/g, m => autoLink(m));
  // action buttons: [[btn:act|Label]] and [Label](action:act)
  s = s.replace(/\[\[btn:([a-z0-9_-]+)(?:\|([^\]]+))?\]\]/gi, (_,a,label)=>`<button class="btn action" data-action="${a}">${label?escapeHtml(label):a}</button>`);
  s = s.replace(/\[([^\]]+)\]\(action:([a-z0-9_-]+)\)/gi, (_,label,act)=>`<button class="btn action" data-action="${act}">${escapeHtml(label)}</button>`);
  return s;
}




/* Restore */
(function(){ setTheme(localStorage.getItem('tl_theme')||'blue'); if(localStorage.getItem('tl_reading')==='1') document.documentElement.classList.add('reading'); })();

// ====== TTS (SpeechSynthesis) ======
(function(){
  if(!('speechSynthesis' in window)){ console.warn('SpeechSynthesis n√£o suportado'); return; }
  window.__tts_on = false;
  let __tts_voice = null;
  function pickPTBRVoice(){
    const voices = speechSynthesis.getVoices();
    const cand = voices.find(v => /pt[-_]BR/i.test(v.lang)) || voices.find(v => /pt/i.test(v.lang));
    return cand || voices[0] || null;
  }
  function ensureVoice(){
    if(!__tts_voice){ __tts_voice = pickPTBRVoice(); }
  }
  function speakText(text){
    if(!window.__tts_on) { if(window.toast) toast('Ative a Voz'); return; }
    if(!text || !text.trim()) return;
    ensureVoice();
    speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    if(__tts_voice) u.voice = __tts_voice;
    u.lang = (__tts_voice && __tts_voice.lang) || 'pt-BR';
    u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
    speechSynthesis.speak(u);
  }
  function stopTTS(){ speechSynthesis.cancel(); }
  function getSelectedText(){ return (window.getSelection && String(window.getSelection())) || ''; }
  function setTTS(on){
    window.__tts_on = !!on;
    const b = document.getElementById('btn-tts');
    if(b) b.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
    if(window.toast) toast(window.__tts_on ? 'Voz ativada' : 'Voz desativada');
  }
  document.addEventListener('click',(e)=>{
    if(e.target && e.target.id==='btn-tts'){ setTTS(!window.__tts_on); return; }
    if(e.target && e.target.id==='btn-tts-sel'){ const t=getSelectedText(); if(t) speakText(t); else if(window.toast) toast('Selecione um trecho primeiro'); return; }
    if(e.target && e.target.id==='btn-tts-stop'){ stopTTS(); return; }
    if(!window.__tts_on) return;
    const block = e.target.closest('p, li, blockquote, .coach, .callout, .equation, pre, td, th');
    if(!block) return;
    if(e.target.closest('button,a,.emoji-btn,.chip,.btn,#fab,.menu,#ttsDock')) return;
    let text = block.innerText || '';
    text = text.replace('Copiar','').trim();
    if(text) speakText(text);
  });
  if('speechSynthesis' in window){
    speechSynthesis.onvoiceschanged = () => { if(!__tts_voice) __tts_voice = pickPTBRVoice(); };
  }
  window.__tts = { set:setTTS, speak:speakText, stop:stopTTS };
})();
// ====================================

async function copy(el){
  const txt=(el.innerText||'').replace('Copiar','').trim();
  try{ await navigator.clipboard.writeText(txt); toast('Copiado'); }
  catch(e){ console.warn('copy fail', e); }
}

  // Allow pasting clipboard content into the Auto‚ÄëGerar textarea.
  async function pasteSrcText(){
    try{
      const text = await navigator.clipboard.readText();
      const ta = document.getElementById('srcText');
      if(ta){
        ta.value = text || '';
        toast('Colado do clipboard');
      }
    }catch(e){
      console.warn('paste fail', e);
      toast('Falha ao colar');
    }
  }

</script>
<script id="STORAGE_FORCE_BRUTE_V1">
(()=>{ 'use strict';
const NS_VER = 'infodose::v3::';
const SUSPECT = ['infodose','book','reject','metalux','kodux','livro','tl_','LIVRO_LIB_V','LIVRO_CUR_V'];
function isSuspect(k){ return SUSPECT.some(p=>k.toLowerCase().includes(p)); }
function now(){return new Date().toISOString().replace(/[:.]/g,'-');}
function backupKey(k){
  const v = localStorage.getItem(k);
  if(v!==null){ localStorage.setItem(`backup::${k}::${Date.now()}`, v); }
}
function migrateAndClean(){
  try{
    // Migrate JSON suspect keys into namespaced infodose::v3::<safe>
    const keys = Object.keys(localStorage);
    for(const k of keys){
      if(k.startsWith(NS_VER)) continue;
      if(!isSuspect(k)) continue;
      const raw = localStorage.getItem(k);
      try{
        const val = JSON.parse(raw);
        // save under safe key
        const safeKey = k.replace(/[^a-z0-9]/gi,'_').toLowerCase();
        localStorage.setItem(`${NS_VER}${safeKey}`, JSON.stringify(Object.assign({}, val, {version:3})));
        backupKey(k);
      }catch(e){
        // not JSON, backup then remove
        backupKey(k);
      }
    }
    // Now remove suspect keys that are outside namespace
    for(const k of Object.keys(localStorage)){
      if(k.startsWith(NS_VER)) continue;
      if(isSuspect(k)){
        // Already backed up above; remove to avoid old code pulling it
        localStorage.removeItem(k);
      }
    }
    // Mark done
    localStorage.setItem(`${NS_VER}__migration_done`, now());
    console.info('[FORCE_BRUTE] migration+clean done');
  }catch(e){
    console.error('[FORCE_BRUTE] failed', e);
  }
}
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    const done = localStorage.getItem(`${NS_VER}__migration_done`);
    if(!done){
      // run migration/clean
      migrateAndClean();
      // reload to let app start fresh
      try{ location.reload(); }catch(e){ console.warn('reload failed', e); }
    }
  }catch(e){ console.error(e); }
});
})();

function autoBuildNested(text){
  closeImporter();
  const root = document.getElementById('root');
  root.innerHTML = '';

  const stack = [];
  function newSectionAt(level, title){
    const details = document.createElement('details');
    details.className = 'acc';
    details.open = false;
    const sum = document.createElement('summary');
    sum.innerHTML = '<span class="chev"></span><h2>'+ title +'</h2>';
    const cont = document.createElement('div'); cont.className = 'sec';
    details.append(sum, cont);
    const parentContainer = stack.length ? stack[stack.length-1].container : root;
    parentContainer.appendChild(details);
    stack.push({level, details, container: cont});
  }
  function currentContainer(){ return stack.length ? stack[stack.length-1].container : root; }

  const lines = text.replace(/\r\n?/g,'\n').split('\n');
  let i = 0, inCode = false, codeLang = '', buf = [];
  let inFn = false, fnDepth = 0;
  // RAW HTML inline (iframe, video, etc.) para o builder aninhado
  const RX_RAW_INLINE = /^\s*<\s*(iframe|video|audio|img|figure|div|section|article|embed|object|svg)\b/i;
    const flushParagraph = ()=>{
    if(!buf.length) return;
    const content = buf.join(' ').trim();

    // Bloco de fun√ß√£o inteira (continua igual)
    if(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{[^]*\}\s*$/.test(content)){
      const div = document.createElement('div');
      div.className = 'equation copyable fn';
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + content;
      div.onclick = ()=>copy(div);
      currentContainer().appendChild(div);
      buf.length = 0;
      return;
    }

    // üî• HTML inline (iframe, video, etc.) ‚Äî renderiza como HTML real
    if(/^\s*</.test(content) && RX_RAW_INLINE.test(content)){
      const wrap = document.createElement('div');
      wrap.innerHTML = content;
      currentContainer().appendChild(wrap);
      buf.length = 0;
      return;
    }

    // Padr√£o: par√°grafo markdown
    const p = document.createElement('p');
    p.innerHTML = inlineMD(content);
    currentContainer().appendChild(p);
    buf.length = 0;
  };

  while(i < lines.length){
    let line = lines[i];
    let norm = line.replace(/[‚Äô‚Äò]/g, "'");

    // headings aninhados
    const mH = line.match(/^\s*(#{1,6})\s+(.+?)\s*$/);
    if(mH){
      flushParagraph();
      const level = mH[1].length, title = mH[2].trim();
      while(stack.length && stack[stack.length-1].level >= level) stack.pop();
      newSectionAt(level, title);
      i++; continue;
    }

    // code fences
    const mFenceOpen = norm.match(/^\s*(?:```|''')([\w-]+)?\s*$/);
    if(!inCode && mFenceOpen){
      flushParagraph();
      inCode = true; codeLang = (mFenceOpen[1]||'').toLowerCase();
      i++; continue;
    }
    if(inCode){
      const mFenceClose = norm.match(/^\s*(?:```|''')+\s*$/);
      if(mFenceClose){
        const pre = document.createElement('pre');
        pre.className = 'md-code copyable';
        const hint = document.createElement('span'); hint.className = 'copy-hint'; hint.textContent = 'Copiar';
        const code = document.createElement('code');
        if(codeLang) code.className = 'lang-'+codeLang;
        code.textContent = buf.join('\n');
        pre.append(hint, code);
        pre.onclick = ()=>copy(pre);
        currentContainer().appendChild(pre);
        buf.length = 0; inCode = false; codeLang = '';
      }else{
        buf.push(line);
      }
      i++; continue;
    }

    // fun√ß√£o multi-linha
    if(!inFn){
      const mFnStart = norm.match(/^\s*(?:export\s+)?function\s+\w+\s*\([^)]*\)\s*\{\s*$/);
      if(mFnStart){
        flushParagraph();
        inFn = true; fnDepth = 1; buf.length = 0; i++; continue;
      }
    }
    if(inFn){
      buf.push(line);
      const open = (line.match(/\{/g) || []).length;
      const close = (line.match(/\}/g) || []).length;
      fnDepth += open - close;
      i++;
      if(fnDepth <= 0){
        const div = document.createElement('div');
        div.className = 'equation copyable fn';
        div.innerHTML = '<span class="copy-hint">Copiar</span>' + escapeHtml(buf.join('\\n'));
        div.onclick = ()=>copy(div);
        currentContainer().appendChild(div);
        buf.length = 0; inFn = false; fnDepth = 0;
      }
      continue;
    }

    // hr
    if(/^\s*(?:---|\*\*\*)\s*$/.test(line)){
      flushParagraph();
      const hr = document.createElement('div'); hr.className = 'hr';
      currentContainer().appendChild(hr); i++; continue;
    }

    // blockquotes aninhados
    if(/^\s*>+/.test(line)){
      flushParagraph();
      const items = [];
      while(i < lines.length && /^\s*>+/.test(lines[i])){
        const m = lines[i].match(/^\s*(>+)\s?(.*)$/);
        items.push({ level: m[1].length, text: m[2] });
        i++;
      }
      const rootBQ = document.createElement('blockquote');
      rootBQ.className = 'bq copyable bq-l1';
      rootBQ.innerHTML = '<span class="copy-hint">Copiar</span>';
      let currentLevel = 1;
      const stackBQ = [rootBQ];
      items.forEach(({level, text})=>{
        while(level > currentLevel){
          const inner = document.createElement('blockquote');
          inner.className = 'bq bq-l' + Math.min(currentLevel+1,3);
          stackBQ[stackBQ.length-1].appendChild(inner);
          stackBQ.push(inner);
          currentLevel++;
        }
        while(level < currentLevel){
          stackBQ.pop();
          currentLevel--;
        }
        const divLine = document.createElement('div');
        divLine.className = 'bq-line';
        divLine.innerHTML = inlineMD(text);
        stackBQ[stackBQ.length-1].appendChild(divLine);
      });
      rootBQ.onclick = ()=>copy(rootBQ);
      currentContainer().appendChild(rootBQ);
      continue;
    }

    // callouts estendidos
    const mCallAny = norm.match(/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+(.*)$/i);
    if(mCallAny){
      flushParagraph();
      let kind = 'note';
      if(mCallAny[1] === '::.') kind = 'aside';
      else if(mCallAny[1] === ':') kind = 'note';
      else if(mCallAny[1] === '?') kind = 'question';
      else kind = (mCallAny[2] || 'info').toLowerCase();

      let textBuf = [mCallAny[3]];
      let j = i + 1;
      while (j < lines.length) {
        const nextLine = lines[j];
        const nextNorm = nextLine.replace(/[‚Äô‚Äò]/g, "'").trim();
        if (nextNorm === '') break;
        if (/^\s*(::(info|warn|tip|note|success|danger)|::\.|:|\?)\s+/i.test(nextNorm)) break;
        textBuf.push(nextLine.trim());
        j++;
      }
      i = j;
      const div = document.createElement('div');
      div.className = 'callout copyable ' + kind;
      div.innerHTML = '<span class="copy-hint">Copiar</span>' + inlineMD(textBuf.join(' '));
      div.onclick = ()=>copy(div);
      currentContainer().appendChild(div);
      continue;
    }

    // math $$ ‚Ä¶ $$
    if(/^\s*\$\$\s*$/.test(line)){
      flushParagraph(); i++;
      let math = '';
      while(i<lines.length && !/^\s*\$\$\s*$/.test(lines[i])){ math += lines[i++] + '\\n'; }
      const eq = document.createElement('div');
      eq.className = 'equation copyable';
      eq.innerHTML = '<span class="copy-hint">Copiar</span>'+ escapeHtml(math.trim());
      eq.onclick = ()=>copy(eq);
      currentContainer().appendChild(eq);
      if(i<lines.length) i++;
      continue;
    }

    // table
    if(/^\s*\|.*\|\s*$/.test(line)){
      flushParagraph();
      let rows = [ line ];
      while(i+1<lines.length && /^\s*\|.*\|\s*$/.test(lines[i+1])){ rows.push(lines[++i]); }
      const tbl = document.createElement('table'); tbl.className='md-table';
      rows.forEach((r,idx)=>{
        const tr = document.createElement('tr');
        const cells = r.trim().slice(1,-1).split('|').map(c=>c.trim());
        const isSep = (idx===1 && cells.every(x=>/^:?-{3,}:?$/.test(x)));
        if(isSep) return;
        cells.forEach(c=>{
          const cell = document.createElement((idx===0)?'th':'td');
          cell.innerHTML = inlineMD(c);
          tr.appendChild(cell);
        });
        tbl.appendChild(tr);
      });
      currentContainer().appendChild(tbl); i++; continue;
    }

    // listas
    const mLi = line.match(/^\s*(?:([-*+])\s+|\d+\.\s+)(.+)$/);
    if(mLi){
      flushParagraph();
      const ordered = /^\s*\d+\.\s+/.test(line);
      const list = document.createElement(ordered?'ol':'ul');
      list.className = 'md-list';
      while(i<lines.length){
        const l = lines[i];
        if(!/^\s*(?:[-*+]\s+|\d+\.\s+)/.test(l)) break;
        const raw = l.replace(/^\s*(?:[-*+]\s+|\d+\.\s+)/,'');
        const task = raw.match(/^\s*\[( |x|X)\]\s*(.*)$/);
        const li = document.createElement('li');
        li.className = 'md-li';
        if(task){
          if(!list.classList.contains('md-task')) list.classList.add('md-task');
          const box = document.createElement('input'); box.type='checkbox'; box.checked = /x/i.test(task[1]); box.disabled = true;
          const span = document.createElement('span'); span.innerHTML = inlineMD(task[2]);
          li.append(box, span);
        }else{
          li.innerHTML = inlineMD(raw);
        }
        list.appendChild(li); i++;
      }
      currentContainer().appendChild(list); continue;
    }

    // par√°grafos
    if(line.trim()===''){ flushParagraph(); i++; continue; }
    buf.push(line.trim()); i++;
  }
  flushParagraph();
  toast('Livro (aninhado) gerado!');
}

</script>

<script>
const DEMO_MD = "# Demo \u2014 A\u00e7\u00f5es e Blocos\n\n[[btn:gerar|Gerar (texto do editor)]] [[btn:nested|Gerar (aninhado)]] [[btn:md|Salvar .md]] [[btn:pdf|Imprimir PDF]]\n\n: Esta p\u00e1gina demonstra **bot\u00f5es inline** que executam as MESMAS a\u00e7\u00f5es dos bot\u00f5es do topo.\n\n## Fun\u00e7\u00e3o em aspas (render == equa\u00e7\u00e3o)\n\u201cfunction pulse(t){ return Math.cos(t) * 0.369; }\u201d\n\n## Cita\u00e7\u00f5es\n> n\u00edvel 1\n>> n\u00edvel 2\n>>> n\u00edvel 3\n\n## Callouts\n: Nota simples\n::warn Aten\u00e7\u00e3o\n::. Aside\n? Pergunta\n\n## Lista de tarefas\n- [ ] pendente\n- [x] feita\n\n## Tabela\n| A | B |\n|---|---|\n| 1 | 2 |\n\n## C\u00f3digo (aspas)\n'''js\nconsole.log(\"ok das aspas\");\n'''\n";
const ACTIONS = {
  demo(){ autoBuild(DEMO_MD); },
  gerar(){ const v = (document.getElementById('srcText')?.value||'').trim(); autoBuild(v || DEMO_MD); },
  nested(){ const v = (document.getElementById('srcText')?.value||'').trim(); if(typeof autoBuildNested==='function') autoBuildNested(v || DEMO_MD); else autoBuild(v || DEMO_MD); },
  importar(){ if(typeof openImporter==='function') openImporter(); },
  md(){
    // Call the global exportMD implementation if available.
    if(typeof window.exportMD === 'function') window.exportMD();
  },
  pdf(){ window.print(); },
  reading(){ if(typeof toggleReading==='function') toggleReading(); },
  theme(){ if(typeof cycleTheme==='function') cycleTheme(); },
  limpar(){ const r=document.getElementById('root'); if(r) r.innerHTML=''; toast && toast('Limpou'); },
  tts(){ document.getElementById('btn-tts')?.click(); },
  'tts-sel'(){ document.getElementById('btn-tts-sel')?.click(); },
  'tts-stop'(){ document.getElementById('btn-tts-stop')?.click(); }
};
document.addEventListener('click', (e)=>{
  const a = e.target.closest('[data-action]');
  if(!a) return;
  const act = a.dataset.action;
  if(act && ACTIONS[act]){ e.preventDefault(); ACTIONS[act](a); }
});
</script>


<script>
/* ===== Biblioteca local (Stacks) ===== */
const LIB_NS = 'tl_library_v1';
function libLoad(){ try{ return JSON.parse(localStorage.getItem(LIB_NS)||'[]'); }catch{return []} }
function libSave(arr){ localStorage.setItem(LIB_NS, JSON.stringify(arr)); }
function libAdd(doc){ const arr=libLoad(); arr.unshift(doc); libSave(arr); }
function libDel(id){ libSave(libLoad().filter(d=>d.id!==id)); }
function libUpdate(id, patch){ libSave(libLoad().map(d=> d.id===id? Object.assign({}, d, patch): d)); }
function analyzeMD(md){
  const words=(md.match(/\S+/g)||[]).length;
  const headings=(md.match(/^\s*#/gm)||[]).length;
  const code=(md.match(/^\s*```/gm)||[]).length;
  const quotes=(md.match(/^\s*>/gm)||[]).length;
  return {words, headings, code, quotes};
}

/* ===== Helpers de MD ===== */
function buildMDFromDOM(){
  const parts=[];
  document.querySelectorAll('#root details.acc').forEach(d=>{
    const h=d.querySelector('summary h2'); if(h) parts.push('# '+h.textContent.trim());
    d.querySelectorAll('.sec > *').forEach(node=>{
      if(node.matches('p')) parts.push(node.innerText.trim());
      else if(node.matches('blockquote')) parts.push('> '+node.innerText.replace('Copiar','').trim());
      else if(node.matches('pre.md-code')) parts.push('```\n'+(node.querySelector('code')?.textContent||'')+'\n```');
      else if(node.matches('.equation')) parts.push('$$\n'+node.innerText.replace('Copiar','').trim()+'\n$$');
      else if(node.matches('ul.md-task')){
        node.querySelectorAll('li').forEach(li=>{
          const chk=li.querySelector('input[type=checkbox]'); const t=li.innerText.replace('Copiar','').trim();
          parts.push(`- [${chk&&chk.checked?'x':' '}] ${t}`);
        });
      }else if(node.matches('ul,ol')){
        const isOl=node.matches('ol'); let idx=1;
        node.querySelectorAll('li').forEach(li=>{
          const txt=li.innerText.trim();
          parts.push((isOl? (idx++)+'. ' : '- ')+txt);
        });
      }else if(node.matches('table.md-table')){
        const rows=[...node.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
        if(rows.length){
          parts.push('| '+rows[0].join(' | ')+' |');
          parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
          rows.slice(1).forEach(r=>parts.push('| '+r.join(' | ')+' |'));
        }
      }
    });
  });
  return parts.join('\n\n');
}
function getCurrentMarkdown(){ return (window.__current_md && window.__current_md.trim()) ? window.__current_md : buildMDFromDOM(); }
window.exportMD = function(){
  const md = buildMDFromDOM();
  const blob=new Blob([md],{type:'text/markdown'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
  const basename = (window.__current_title||'export').replace(/[\\\/:*?"<>|]+/g,'-').slice(0,80)||'export';
  a.download= basename + '.md'; a.click(); URL.revokeObjectURL(a.href);
  toast && toast('.md exportado');
};

/* ===== Bloco Mestre (sempre topo) ===== */
function ensureMasterBlock(){
  const root=document.getElementById('root'); if(!root) return;
  let mb=document.getElementById('masterBlock');
  if(!mb){
    mb=document.createElement('div'); mb.id='masterBlock'; mb.className='master-block';
    root.prepend(mb);
  }
  const safeTitle=(window.__current_title||'').replace(/[<>&]/g, s=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[s]));
  mb.innerHTML = `<div class="row">
    <input id="docTitle" class="title" placeholder="T√≠tulo do documento" value="${safeTitle}">
    <button class="btn" data-action="copiar-tudo">Copiar tudo</button>
    <button class="btn" data-action="tts">TTS On/Off</button>
    <button class="btn" data-action="md">Exportar .md</button>
    <button class="btn" data-action="pdf">Imprimir (PDF)</button>
    <button class="btn" data-action="abrir-tudo">Abrir tudo</button>
    <button class="btn" data-action="fechar-tudo">Fechar tudo</button>
    <button class="btn" data-action="save">Salvar</button>
  </div>`;
}

/* ===== Comandos do Bloco Mestre ===== */
function openAll(){ document.querySelectorAll('#root details.acc').forEach(d=> d.open=true); }
function closeAll(){ document.querySelectorAll('#root details.acc').forEach(d=> d.open=false); }
async function copyAll(){
  const md=getCurrentMarkdown();
  try{ await navigator.clipboard.writeText(md); toast && toast('Conte√∫do copiado'); }catch(e){ console.warn(e); }
}
function saveCurrent(){
  const md=getCurrentMarkdown();
  const titleInput=document.getElementById('docTitle');
  const title=(titleInput&&titleInput.value.trim()) || (md.match(/^\s*#\s+(.+)$/m)?.[1]) || 'Sem t√≠tulo';
  const now=new Date().toISOString();
  const id='doc_'+Date.now();
  const doc={id,title,md,createdAt:now,updatedAt:now,bytes:md.length};
  libAdd(doc);
  localStorage.setItem('tl_last_doc_id', id);
  toast && toast('Salvo em Stacks');
}

/* ===== Pr√©-processamento (arrow => $$, aside normalizado) ===== */
function preprocessMD(text){
  const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
  const out=[]; let i=0;
  while(i<lines.length){
    let l=lines[i];
    let norm=l.replace(/[‚Äô‚Äò]/g,"'").replace(/[‚Äú‚Äù]/g,'"');

    // ::aside -> ::. ; e garante "::. " (com espa√ßo) quando vazio
    if(/^\s*::aside\b/i.test(norm)){ l = l.replace(/^\s*::aside\b/i, '::.'); norm=l.replace(/[‚Äô‚Äò]/g,"'").replace(/[‚Äú‚Äù]/g,'"'); }
    if(/^\s*::\.\s*$/.test(norm)){ l = '::. '; norm = l; }

    // Arrow block multilinha com chaves
    if(/^\s*(?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*\{\s*$/.test(norm)){
      const buf=[l]; let depth=((l.match(/\{/g)||[]).length - (l.match(/\}/g)||[]).length); i++;
      while(i<lines.length){
        buf.push(lines[i]);
        depth += ((lines[i].match(/\{/g)||[]).length - (lines[i].match(/\}/g)||[]).length);
        i++;
        if(depth<=0) break;
      }
      out.push('$$'); out.push(...buf); out.push('$$'); continue;
    }
    // Fun√ß√£o citada "function ... { ... }"
    let m = norm.match(/^[\"']\s*((?:export\s+)?function\s+[A-Za-z_$][\w$]*\s*\([^)]*\)\s*\{[^}]*\})\s*[\"']\s*$/);
    if(m){ out.push('$$'); out.push(m[1]); out.push('$$'); i++; continue; }
    // Arrow citada "const f = ... => ..."
    let m2 = norm.match(/^[\"']\s*((?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*(?:\{[^}]*\}|[^;]+;?))\s*[\"']\s*$/);
    if(m2){ out.push('$$'); out.push(m2[1]); out.push('$$'); i++; continue; }
    // Arrow one-liner
    if(/^\s*(?:const|let|var)\s+[A-Za-z_$][\w$]*\s*=\s*(?:\([^)]*\)|[A-Za-z_$][\w$]*)\s*=>\s*(?:\{[^}]*\}|[^;]+;?)\s*$/.test(norm)){
      out.push('$$'); out.push(l); out.push('$$'); i++; continue;
    }
    out.push(l); i++;
  }
  return out.join('\n');
}

/* ===== Envelopa os builders para usar preprocess + bloco mestre ===== */
(function(){
  if(typeof window.autoBuild==='function'){
    const __orig = window.autoBuild;
    window.autoBuild = function(text){
      text = preprocessMD(text||'');
      window.__current_md = text;
      window.__current_title = (text.match(/^\s*#\s+(.+)$/m)||[])[1] || (document.title||'');
      __orig(text);
      ensureMasterBlock();
    }
  }
  if(typeof window.autoBuildNested==='function'){
    const __origN = window.autoBuildNested;
    window.autoBuildNested = function(text){
      text = preprocessMD(text||'');
      window.__current_md = text;
      window.__current_title = (text.match(/^\s*#\s+(.+)$/m)||[])[1] || (document.title||'');
      __origN(text);
      ensureMasterBlock();
    }
  }
})();

/* ===== Home (stacks) ===== */
function renderWelcome(){
  const name = localStorage.getItem('tl_user_name')||'';
  const root = document.getElementById('root');
  const stacks = libLoad();
  const cards = stacks.map(d=>{
    const a = analyzeMD(d.md);
    const dt = new Date(d.updatedAt||d.createdAt||Date.now()).toLocaleString();
    return `
    <div class="stack-card">
      <h4>${escapeHtml(d.title||'Sem t√≠tulo')}</h4>
      <div class="meta">${dt} ¬∑ ${a.words} palavras</div>
      <div class="row">
        <button class="btn" data-action="open-doc" data-id="${d.id}">Abrir</button>
        <button class="btn" data-action="rename-doc" data-id="${d.id}">Renomear</button>
        <button class="btn" data-action="analisar-doc" data-id="${d.id}">Analisar</button>
        <button class="btn" data-action="md-doc" data-id="${d.id}">Exportar .md</button>
        <button class="btn" data-action="del-doc" data-id="${d.id}">Excluir</button>
      </div>
    </div>`;
  }).join('');

  root.innerHTML = `
  <details class="acc" open>
    <summary><span class="chev"></span><h2>üëã Boas‚Äëvindas${name? (', '+escapeHtml(name)) : ''}</h2></summary>
    <div class="sec">
      <div class="welcome">
        <div class="row" style="gap:8px;align-items:center;">
          <input id="welcomeName" class="field" placeholder="Seu nome" value="${escapeHtml(name)}"/>
          <button class="btn" data-action="save-name">Salvar nome</button>
          <button class="btn" data-action="importar">Enviar Documento</button>
          <button class="btn" data-action="demo">Gerar Demo</button>
          <button class="btn" data-action="gerar">Gerar do Editor</button>
          <button class="btn" data-action="nested">Gerar (aninhado)</button>
          <button class="btn" data-action="md">Exportar .md</button>
          <button class="btn" data-action="pdf">Imprimir (PDF)</button>
          <button class="btn" data-action="reading">Modo Leitura</button>
          <button class="btn" data-action="theme">Trocar Tema</button>
        </div>
        <div class="small" style="margin-top:8px">Stacks salvos no dispositivo:</div>
        <div class="stack-grid">${cards || '<div class="small" style="opacity:.8">Sem documentos salvos ainda.</div>'}</div>
      </div>
    </div>
  </details>`;
}

/* ===== Estende ACTIONS ===== */
window.ACTIONS = window.ACTIONS || {};
Object.assign(ACTIONS, {
  'back'(){ try{ if(history.length>1){ history.back(); } else { renderWelcome(); } }catch(e){ renderWelcome(); } },
  
  'abrir-tudo'(){ openAll(); },
  'fechar-tudo'(){ closeAll(); },
  'copiar-tudo'(){ copyAll(); },
  'save'(){ saveCurrent(); },
  'open-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; autoBuild(doc.md); },
  'del-doc'(el){ const id = el?.dataset?.id; libDel(id); renderWelcome(); toast && toast('Documento removido'); },
  'rename-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const novo = prompt('Novo t√≠tulo', doc.title)||''; if(novo.trim()){ libUpdate(id,{title:novo.trim(),updatedAt:new Date().toISOString()}); renderWelcome(); toast && toast('Renomeado'); } },
  'analisar-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const a = analyzeMD(doc.md); toast && toast(`Palavras: ${a.words} ¬∑ H1+: ${a.headings} ¬∑ C√≥digo: ${a.code} ¬∑ Cita√ß√µes: ${a.quotes}`); },
  'md-doc'(el){ const id = el?.dataset?.id; const doc = libLoad().find(d=>d.id===id); if(!doc) return; const blob=new Blob([doc.md],{type:'text/markdown'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(doc.title||'documento')+'.md'; a.click(); URL.revokeObjectURL(a.href); },
  'save-name'(){ const el = document.getElementById('welcomeName'); const v=(el&&el.value||'').trim(); if(v){ localStorage.setItem('tl_user_name', v); toast && toast('Nome salvo'); } else { localStorage.removeItem('tl_user_name'); toast && toast('Nome limpo'); } renderWelcome(); },
  'home'(){ renderWelcome(); },
  'welcome'(){ renderWelcome(); }
});

/* ===== Primeira carga: Home ===== */
document.addEventListener('DOMContentLoaded', ()=>{ renderWelcome(); });
</script>


<script id="PATCH_MASTERBLOCK_HOME_BTN_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);
function ensureHomeInMaster(){
  const area = $('#masterActions');
  if(!area) return;
  if(!area.querySelector('[data-act="home"]')){
    const b = document.createElement('button');
    b.className='chip'; b.textContent='Home'; b.dataset.act='home';
    // Inserir como primeiro bot√£o (antes de Copiar tudo/Iniciar)
    area.insertBefore(b, area.firstChild);
  }
  // Delega√ß√£o de clique para o Master Block
  const block = $('#masterBlock') || document;
  if(!block.dataset.boundHomeAct){
    block.dataset.boundHomeAct='1';
    block.addEventListener('click', (e)=>{
      const t = e.target.closest('[data-act="home"]'); if(!t) return;
      // Reusa ACTIONS.home quando dispon√≠vel; sen√£o fallback para stacks/topo
      if(window.ACTIONS && typeof ACTIONS.home==='function'){ ACTIONS.home(); return; }
      const acc = $('#stackHost details.acc') || $('#stackHost');
      if(acc){ try{ acc.open = true; }catch{}; acc.scrollIntoView({behavior:'smooth', block:'start'}); }
      else window.scrollTo({top:0, behavior:'smooth'});
    }, true);
  }
}
document.addEventListener('DOMContentLoaded', ensureHomeInMaster);
})();</script>

<script id="FAB_MINI_CONFIG">
window.FAB_MINI = window.FAB_MINI || {
  // 'hide' = esconde os outros; 'replace' = troca o menu e mant√©m s√≥ os bot√µes abaixo
  mode: 'replace',
  // incluir Voltar? (false por padr√£o, como voc√™ pediu)
  include_back: false,
  // textos dos bot√µes (pode mudar aqui)
  labels: { autogerar: 'Auto‚ÄëGerar', pdf: 'PDF', tts: 'TTS', home: 'Home', back: 'Voltar' },
  // ganchos do Auto‚ÄëGerar
  autogerar: {
    // roda antes do Auto‚ÄëGerar (ex.: setar tema/seed/clean)
    before: null,
    // override do fluxo de gera√ß√£o; se n√£o definir, tentamos openImporter() ‚Üí ACTIONS.demo() ‚Üí autoBuild()
    run: null
  }
};
</script>
<script id="PATCH_FAB_MINI_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const CFG = window.FAB_MINI || (window.FAB_MINI = {
  mode:'replace', include_back:false,
  labels:{ autogerar:'Auto‚ÄëGerar', pdf:'PDF', tts:'TTS', home:'Home', back:'Voltar' },
  autogerar:{ before:null, run:null }
});

function ensureActions(){
  if(!window.ACTIONS) window.ACTIONS = {};

  if(typeof ACTIONS.home!=='function'){
    ACTIONS.home = ()=>{
      if(typeof window.renderWelcome==='function'){ renderWelcome(); return; }
      const acc = $('#stackHost details.acc') || $('#stackHost');
      if(acc){ try{ acc.open = true; }catch{}; acc.scrollIntoView({behavior:'smooth', block:'start'}); }
      else window.scrollTo({top:0, behavior:'smooth'});
    };
  }
  if(typeof ACTIONS.ttsToggle!=='function'){
    ACTIONS.ttsToggle = ()=>{ const b=document.getElementById('btn-tts'); if(b) b.click(); };
  }
  if(typeof ACTIONS.autoGerar!=='function'){
    ACTIONS.autoGerar = ()=>{
      try{ if(typeof CFG.autogerar.before==='function') CFG.autogerar.before(); }catch{}
      if(typeof CFG.autogerar.run==='function') return CFG.autogerar.run();
      if(typeof window.openImporter==='function') return openImporter();
      if(window.ACTIONS?.demo) return ACTIONS.demo();
      if(typeof window.autoBuild==='function') return autoBuild('# Demo\n\n...');
    };
  }
  if(typeof ACTIONS.pdf!=='function'){ ACTIONS.pdf = ()=>window.print(); }
  if(typeof ACTIONS.back!=='function'){
    ACTIONS.back = ()=>{ if(history.length>1) history.back(); else ACTIONS.home?.(); };
  }
}

function rebuildFAB(){
  const menu = $('.fab .menu') || $('#fab .menu') || $('.menu[data-fab]');
  if(!menu) return;

  const keep = ['home','autogerar','tts','pdf']; // ordem desejada
  if(CFG.include_back) keep.splice(1,0,'back'); // op√ß√£o: Home, Back, Auto‚ÄëGerar, TTS, PDF

  if(CFG.mode==='replace'){
    menu.innerHTML='';
  }else{
    // hide todos os outros
    menu.querySelectorAll('.btn,button,a').forEach(el=>{
      if(!keep.includes(el.dataset.action)) el.style.display='none';
    });
  }

  const make = (act,text)=>{
    const b=document.createElement('button'); b.className='btn'; b.dataset.action=act; b.textContent=text; return b;
  };
  const label = CFG.labels || {};
  keep.forEach(act=>{
    const sel = `[data-action="${act}"]`;
    const txt = label[act] || ({home:'Home',back:'Voltar',autogerar:'Auto‚ÄëGerar',tts:'TTS',pdf:'PDF'})[act];
    const exists = menu.querySelector(sel);
    if(exists){ exists.textContent = txt; exists.style.display=''; }
    else menu.appendChild(make(act, txt));
  });

  if(!menu.dataset.boundMini){
    menu.dataset.boundMini='1';
    menu.addEventListener('click',(e)=>{
      const b=e.target.closest('[data-action]'); if(!b) return;
      const act=b.dataset.action;
      const map = {home:'home',back:'back',autogerar:'autoGerar',tts:'ttsToggle',pdf:'pdf', dts:'ttsToggle'};
      const fn = map[act] && ACTIONS[map[act]];
      if(typeof fn==='function'){ e.preventDefault(); fn(); }
    }, true);
  }
}

document.addEventListener('DOMContentLoaded', ()=>{ ensureActions(); rebuildFAB(); });
})();
</script>

<script id="ORB2D_ENGINE_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const ARQ = window.ARQ || (window.ARQ = {
  current: (localStorage.getItem('tl_arq')||'madeira').toLowerCase(),
  map: {
    madeira: { a:'#36f6a2', b:'#00ffa8', name:'Madeira' },
    agua:    { a:'#67e6ff', b:'#3bd3ff', name:'√Ågua' },
    fogo:    { a:'#ff7a00', b:'#ff3366', name:'Fogo' },
    terra:   { a:'#c8a46e', b:'#8a6c3d', name:'Terra' },
    metal:   { a:'#dfe7ff', b:'#a0b7ff', name:'Metal' },
  }
});

function applyArq(name){
  name = (name||'').toLowerCase();
  const cfg = ARQ.map[name] || ARQ.map.madeira;
  ARQ.current = name in ARQ.map ? name : 'madeira';
  localStorage.setItem('tl_arq', ARQ.current);
  const root = document.documentElement;
  root.style.setProperty('--orb-a', cfg.a);
  root.style.setProperty('--orb-b', cfg.b);
  document.body.dataset.arq = ARQ.current;
  if(window.toast) toast('Arqu√©tipo: '+(cfg.name||name));
  window.dispatchEvent(new CustomEvent('archetypechange',{ detail:{ name: ARQ.current, colors: cfg } }));
}

function ensureOrb(){
  const fab = $('#fab'); if(!fab) return;
  let orb = $('#orb2d');
  if(!orb){
    orb = document.createElement('button');
    orb.id='orb2d'; orb.title='Abrir apps';
    fab.appendChild(orb);
  }
  // quick picker
  let picker = $('#orb-picker');
  if(!picker){
    picker = document.createElement('div');
    picker.id = 'orb-picker';
    picker.innerHTML = `
      <button class="chip" data-arq="madeira">Madeira</button>
      <button class="chip" data-arq="agua">√Ågua</button>
      <button class="chip" data-arq="fogo">Fogo</button>
      <button class="chip" data-arq="terra">Terra</button>
      <button class="chip" data-arq="metal">Metal</button>
    `;
    fab.appendChild(picker);
  }
  // tap toggles menu
  orb.addEventListener('click', ()=> fab.classList.toggle('open'));
  // long press opens picker
  let pressTimer=null;
  orb.addEventListener('pointerdown', ()=>{
    clearTimeout(pressTimer);
    pressTimer = setTimeout(()=> fab.classList.toggle('show-picker'), 500);
  });
  ['pointerup','pointerleave','pointercancel'].forEach(evt=> orb.addEventListener(evt, ()=> clearTimeout(pressTimer)));
  picker.addEventListener('click', (e)=>{
    const b = e.target.closest('[data-arq]'); if(!b) return;
    applyArq(b.dataset.arq);
    fab.classList.remove('show-picker');
  });
}

document.addEventListener('DOMContentLoaded', ()=>{
  ensureOrb();
  applyArq(ARQ.current);
});

// API p√∫blica
window.ARQ = Object.assign(ARQ, {
  set: applyArq,
  cycle(){
    const list = Object.keys(ARQ.map);
    const i = Math.max(0, list.indexOf(ARQ.current));
    const next = list[(i+1)%list.length];
    applyArq(next);
  }
});
})();
</script>


<script id="HERBIE_ENGINE_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

const HERBIE = window.HERBIE || (window.HERBIE = {
  preset: (localStorage.getItem('herbiePreset')||'blue').toLowerCase(),
  presets: {
    blue:    { a:'#67e6ff', b:'#3bd3ff', name:'Blue' },
    gold:    { a:'#f7d774', b:'#ffcc55', name:'Gold' },
    thermal: { a:'#ff7a00', b:'#ff3366', name:'Thermal' },
  },
  setPreset(name){
    name=(name||'').toLowerCase();
    const p=this.presets[name]||this.presets.blue;
    this.preset = name in this.presets ? name : 'blue';
    localStorage.setItem('herbiePreset', this.preset);
    const root=document.documentElement;
    root.style.setProperty('--orb-a', p.a);
    root.style.setProperty('--orb-b', p.b);
    window.dispatchEvent(new CustomEvent('herbiechange',{detail:{ name:this.preset, colors:p }}));
    if(window.toast) toast('Preset: '+(p.name||name));
  },
  setButtonsOpacity(v){
    const val=Math.max(.2, Math.min(1, Number(v)||.92));
    document.documentElement.style.setProperty('--fab-btn-opacity', String(val));
    localStorage.setItem('herbieBtnOpacity', String(val));
  },
  cyclePresets(){
    const list=Object.keys(this.presets); const i=list.indexOf(this.preset);
    this.setPreset(list[(i+1)%list.length]);
  }
});

// augment ORB picker with preset chips
function enhancePicker(){
  const fab=$('#fab'); if(!fab) return;
  let picker = $('#orb-picker');
  if(!picker) return;
  if(!picker.querySelector('.row-presets')){
    const row = document.createElement('div');
    row.className='row-presets';
    row.style.marginTop='6px';
    row.innerHTML = `
      <button class="chip" data-preset="blue">Blue</button>
      <button class="chip" data-preset="gold">Gold</button>
      <button class="chip" data-preset="thermal">Thermal</button>`;
    picker.appendChild(row);
    picker.addEventListener('click', (e)=>{
      const b=e.target.closest('[data-preset]'); if(!b) return;
      HERBIE.setPreset(b.dataset.preset);
      fab.classList.remove('show-picker');
    });
  }
}

// init
document.addEventListener('DOMContentLoaded', ()=>{
  const savedOpacity = parseFloat(localStorage.getItem('herbieBtnOpacity')||'0');
  if(savedOpacity>0){ HERBIE.setButtonsOpacity(savedOpacity); }
  enhancePicker();
  HERBIE.setPreset(HERBIE.preset);
});

window.HERBIE = HERBIE;
})();
</script>


<!--script id="CSS_INNER_RENDER_V1">
(()=>{'use strict';
const STYLE_ID='INLINE_CSS_RENDER_V1';
function appendCSS(css){
  if(!css || !css.trim()) return;
  let s=document.getElementById(STYLE_ID);
  if(!s){ s=document.createElement('style'); s.id=STYLE_ID; document.head.appendChild(s); }
  s.appendChild(document.createTextNode('\n'+css));
}

window.CSS_INNER = {
  // Varre o DOM e injeta CSS encontrado em blocos comuns
  applyFromDOM(){
    let css='';
    document.querySelectorAll('style[data-inline], [data-css-inline], pre[data-lang="css"], code.language-css, pre code.css').forEach(el=>{
      const t = (el.textContent||'').trim();
      if(t) css += '\n' + t;
    });
    appendCSS(css);
  },
  // Extrai <style>...</style> de uma string HTML e aplica
  applyFromHTML(html){
    if(!html) return;
    const re=/<style[^>]*>([\s\S]*?)<\/style>/gi; let m, css='';
    while((m=re.exec(html))){ css += '\n' + (m[1]||''); }
    appendCSS(css);
  }
};
document.addEventListener('DOMContentLoaded', ()=> CSS_INNER.applyFromDOM());
})();
</script--!>


<script id="RAW_HTML_COMPAT_MIN_V1">
(()=>{'use strict';
// Non-destructive shim: preserves your existing builder and design.
// If text contains real HTML blocks, we render with a raw-aware builder;
// otherwise we delegate to the original builder untouched.

const $=(q,r=document)=>r.querySelector(q);

const RX_RAW_OPEN=/^\s*<\s*(div|figure|iframe|video|audio|svg|object|embed|table|section|article|img|pre|code|details|blockquote)\b/i;
const RX_RAW_SELF=/^\s*<(img|hr|br|embed|source|track|col|meta|link)\b[^>]*\/?>\s*$/i;
const RX_DIVIDER=/^\s*(?:---|\*\*\*)\s*$/;
const RX_HEADING=/^\s*(#{1,6})\s+(.+)$/;
// Expanded RX_CALL to also recognize shorter callouts like ":" (note) and "?" (question) and the "::." syntax for asides.
const RX_CALL=/^\s*(::(?:info|warn|tip|note|meta|ritual|success|danger|aside|question)|::\.|:|\?)\s+(.*)$/i;

function appendRaw(to, html){
  const tmp=document.createElement('div'); tmp.innerHTML = html;
  [...tmp.childNodes].forEach(n=>to.appendChild(n));
}

function rawAwareBuild(text){
  const root = $('#root'); if(!root) return;
  root.innerHTML = '';

  const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
  let i=0, sec=null, blocks=0, sawH=false;

  function newSection(title){
    const det=document.createElement('details'); det.className='acc'; det.open=false;
    const sum=document.createElement('summary');
    sum.innerHTML=`<span class="chev"></span><h2>${title||'Se√ß√£o'}</h2>`;
    const cont=document.createElement('div'); cont.className='sec';
    det.append(sum, cont); root.appendChild(det);
    sec=det; blocks=0;
  }
  function ensureSection(){ if(!sec) newSection('Se√ß√£o 1'); if(blocks>=14) newSection(sec.querySelector('h2').textContent+' (cont.)'); }
  function push(el){ ensureSection(); sec.lastChild.appendChild(el); blocks++; }
  const flush = (buf)=>{
    if(!buf.length) return;
    const s = buf.join(' ').trim();
    if(/^\s*</.test(s) && RX_RAW_OPEN.test(s)){
      const d=document.createElement('div'); appendRaw(d, s); push(d);
    }else{
      const p=document.createElement('p');
      p.innerHTML = (window.inlineMD? window.inlineMD(s) : s);
      push(p);
    }
    buf.length=0;
  };

  while(i<lines.length){
    const line = lines[i];

    // hard divider
    if(RX_DIVIDER.test(line)){ flush([]); newSection(); i++; continue; }

    const mH = line.match(RX_HEADING);
    if(mH){ flush([]); newSection(mH[2].trim()); sawH=true; i++; continue; }

    const mC = line.match(RX_CALL);
    if(mC){
      flush([]);
      // Determine callout kind from the marker.
      let marker = (mC[1]||'').toLowerCase();
      let kind;
      if(marker === '::.') {
        kind = 'aside';
      } else if(marker === ':') {
        kind = 'note';
      } else if(marker === '?') {
        kind = 'question';
      } else {
        // strip leading "::" from extended callouts
        if(marker.startsWith('::')) {
          marker = marker.slice(2);
        }
        kind = marker || 'note';
      }
      const div=document.createElement('div');
      div.className=`callout ${kind} copyable`;
      div.innerHTML=`<span class="copy-hint">Copiar</span>` + (window.inlineMD? window.inlineMD(mC[2]) : mC[2]);
      push(div); i++; continue;
    }

    if(RX_RAW_OPEN.test(line)){
      // collect multi-line raw
      let tag = (line.match(RX_RAW_OPEN)||[])[1]||'div';
      const rxClose = new RegExp(`</\\s*${tag}\\s*>`, 'i');
      const buf=[line]; i++;
      while(i<lines.length && !rxClose.test(lines[i]) && !RX_RAW_SELF.test(lines[i])){
        buf.push(lines[i]); i++;
      }
      if(i<lines.length){ buf.push(lines[i]); i++; }
      const d=document.createElement('div'); appendRaw(d, buf.join('\n')); push(d);
      continue;
    }

    // code fences fallback to original builder: we gather and let original handle, or render here
    const mOpen = line.match(/^\s*(?:```|''')\s*([\w-]+)?\s*$/);
    if(mOpen){
      const lang=(mOpen[1]||'').toLowerCase(); i++; const code=[];
      while(i<lines.length && !/^\s*(?:```|''')+\s*$/.test(lines[i])){ code.push(lines[i]); i++; }
      if(i<lines.length) i++;
      const pre=document.createElement('pre'); pre.className='md-code copyable';
      const hint=document.createElement('span'); hint.className='copy-hint'; hint.textContent='Copiar';
      const c=document.createElement('code'); if(lang) c.className='lang-'+lang; c.textContent=code.join('\n');
      pre.append(hint,c); pre.onclick=()=>window.copy&&copy(pre); push(pre); continue;
    }

    if(line.trim()===''){ flush([]); i++; continue; }

    // accumulate paragraph lines
    const acc=[]; acc.push(line.trim()); i++;
    while(i<lines.length && lines[i].trim()!==''){
      if(RX_HEADING.test(lines[i])||RX_DIVIDER.test(lines[i])||RX_CALL.test(lines[i])||RX_RAW_OPEN.test(lines[i])) break;
      acc.push(lines[i].trim()); i++;
    }
    flush(acc);
  }

  // title fallback
  if(!sawH){
    const h = root.querySelector('details.acc summary h2');
    if(h && (!h.textContent || /^Se√ß√£o/.test(h.textContent))) h.textContent = 'Documento';
  }

  // rename if first block is figure with caption
  root.querySelectorAll('details.acc').forEach((d,idx)=>{
    const cap=d.querySelector('figcaption'); const h=d.querySelector('summary h2');
    if(cap && h && /^Se/i.test(h.textContent||'')) h.textContent = cap.textContent.trim();
    if(!cap && h && /^Se/i.test(h.textContent||'')) h.textContent = idx===0? 'Vis√£o' : `Bloco ${idx+1}`;
  });
}

// Wrap original autoBuild safely (idempotent)
(function(){
  const orig = window.autoBuild;
  if(typeof orig!=='function' || orig.__rawAwareWrapped) return;
  window.autoBuild = function(text){
    try{
      const hasRaw = /^(?:\s*<(?:div|figure|iframe|video|audio|svg|object|embed|table|section|article|img|pre|code|details|blockquote)\b)/mi.test(String(text||''));
      if(hasRaw){ return rawAwareBuild(text); }
    }catch{}
    return orig(text);
  };
  window.autoBuild.__rawAwareWrapped = true;
})();

})();
</script>

<!-- ============ Œ£ KaTeX ‚Äî FAB ACTION PATCH (safe with FAB_MINI) ============ -->
<script id="FAB_KATEX_ACTION_V1">
(()=>{'use strict';
const $=(q,r=document)=>r.querySelector(q);

// ‚Äî pega um container ‚Äúativo‚Äù sensato (igual ao master patch)
function getActiveRoot(){
  const picks = [
    '[data-pane="active"]','.stack .doc.active','.pane.active',
    '#renderOut','#mdOut','#viewer','#content','#root','main','article'
  ];
  for(const sel of picks){ const el=$(sel); if(el) return el; }
  return document.body;
}

// ‚Äî a√ß√£o KaTeX
async function runKaTeXActive(){
  try{
    const call = (root)=>{
      if(typeof window.KaTeXRender==='function') return window.KaTeXRender(root);
      // fallback: auto-render global se KaTeX j√° foi carregado
      if(typeof window.renderMathInElement==='function'){
        window.renderMathInElement(root||document.body,{
          delimiters:[
            {left:"$$",right:"$$",display:true},
            {left:"\\[",right:"\\]",display:true},
            {left:"$", right:"$", display:false},
            {left:"\\(", right:"\\)", display:false},
          ],
          throwOnError:false,
          ignoredTags:["script","noscript","style","textarea","code","pre"]
        });
      }
    };
    await call(getActiveRoot());
    (window.toast||console.log)('Œ£ KaTeX: render no painel ativo ‚úì');
  }catch(e){
    console.warn('[FAB_KATEX]', e);
    (window.toast||console.warn)('Falha ao renderizar KaTeX');
  }
}

// ‚Äî garante ACTIONS.katex dispon√≠vel
function ensureAction(){
  window.ACTIONS = window.ACTIONS || {};
  if(typeof window.ACTIONS.katex!=='function'){
    window.ACTIONS.katex = ()=> runKaTeXActive();
  }
}

// ‚Äî cria/injeta o bot√£o na #fab .menu
function ensureFabButton(){
  const menu = document.querySelector('#fab .menu');
  if(!menu) return;
  if(menu.querySelector('[data-action="katex"]')) return;
  const b = document.createElement('button');
  b.className = 'btn';
  b.dataset.action = 'katex';
  b.title = 'Render KaTeX (painel ativo)';
  b.textContent = 'Œ£ KaTeX';
  menu.appendChild(b);
}

// ‚Äî delega clique do FAB pra chamar ACTIONS (segue o teu padr√£o)
function bindFabClicks(){
  const menu = document.querySelector('#fab .menu');
  if(!menu || menu.dataset.kxBound) return;
  menu.dataset.kxBound='1';
  menu.addEventListener('click',(e)=>{
    const t = e.target.closest('[data-action="katex"]'); if(!t) return;
    e.preventDefault(); ensureAction(); window.ACTIONS.katex();
  }, true);
}

// ‚Äî observa o FAB para reinjetar o bot√£o ap√≥s ‚Äúrebuild‚Äù
function watchFab(){
  const container = document.querySelector('#fab');
  if(!container || container.__kxObs) return;
  const obs = new MutationObserver(()=>{ ensureAction(); ensureFabButton(); bindFabClicks(); });
  obs.observe(container, { childList:true, subtree:true });
  container.__kxObs = obs;
}

// boot
function boot(){ ensureAction(); ensureFabButton(); bindFabClicks(); watchFab(); }
if(document.readyState!=='loading') boot();
else document.addEventListener('DOMContentLoaded', boot);

})();
</script>


<!-- ============ LIST/ASCII BEAUTY PATCH ‚Äî V2 (hierarquia + tra√ßo-c√°psula) ============ -->
<style id="LIST_BEAUTY_V2">
/* sem conflito: usa escopo mais espec√≠fico, preservando V1 */
:root{
  --list-bg: color-mix(in oklab, var(--panel, #0e1220) 90%, black);
  --list-border: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --list-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--list-border);
  --list-radius: 16px;
  --list-marker-size: 1.65rem;
  --list-muted: color-mix(in oklab, var(--ink, #e8ecf6) 62%, transparent);
}

/* wrapper visual */
.list-card{ background:var(--list-bg); border-radius:var(--list-radius);
  box-shadow:var(--list-shadow); border:1px solid var(--list-border);
  padding:clamp(.6rem,.9rem,1rem); margin:.85rem 0; }
.list-card ul, .list-card ol{ margin:.25rem 0; padding:0; list-style:none; }
.list-card li{ display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start; padding:.35rem .25rem; }
.list-card li > ul, .list-card li > ol{ margin-top:.35rem; margin-left:1.85rem; }

/* ========= OL: numera√ß√£o hier√°rquica ========= */
.list-card ol.ol-neo{ counter-reset:item; }
.list-card ol.ol-neo li{ counter-increment:item; }
.list-card ol.ol-neo li::before{
  /* hierarquia: 1, 1.1, 1.1.1 */
  content:counters(item, ".");
  inline-size:auto; min-inline-size: var(--list-marker-size);
  block-size: var(--list-marker-size);
  padding:0 .55rem; display:grid; place-items:center;
  font-weight:700; font-variant-numeric: tabular-nums;
  border-radius:12px;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  color:#000; box-shadow:0 2px 10px rgba(0,0,0,.35);
}
/* reseta contador em sub-listas para formar 1.1, 1.2, etc. */
.list-card ol.ol-neo ol{ counter-reset:item; }

/* ========= UL: bullets padr√£o (diamante) ========= */
.list-card ul.ul-neo:not(.style-dash):not([data-bullet="dash"]) > li::before{
  content:"";
  inline-size:.9rem; block-size:.9rem; border-radius:8px;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  box-shadow:0 1px 6px rgba(0,0,0,.35), 0 0 0 1px color-mix(in oklab, #fff 14%, transparent);
  translate:0 .15rem;
}

/* ========= UL: variante ‚Äútra√ßo-c√°psula‚Äù ========= */
.list-card ul.ul-neo.style-dash > li::before,
.list-card ul.ul-neo[data-bullet="dash"] > li::before{
  content: attr(data-marker, "‚Äì"); /* pode trocar por texto: data-marker="TIP" */
  display:inline-grid; place-items:center;
  inline-size:auto; min-inline-size:1.35rem; block-size:1.35rem;
  padding:0 .6rem; border-radius:999px; font-weight:700;
  letter-spacing:.02em;
  background:linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  color:#000; box-shadow:0 2px 10px rgba(0,0,0,.35);
}

/* dica/legenda leve */
.list-card .hint{ color:var(--list-muted); font-size:.9em; }

/* ========= ASCII card (igual V1, com leve glow) ========= */
.ascii-card{ background:var(--list-bg); border-radius:calc(var(--list-radius) + 2px);
  border:1px solid var(--list-border); box-shadow:var(--list-shadow),
  0 0 0 1px color-mix(in oklab, var(--grad-b, #67e6ff) 20%, transparent);
  margin:1rem 0; overflow:auto; }
.ascii-card pre{ margin:0; padding:1rem 1.1rem; line-height:1.35;
  font:500 13.5px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; white-space:pre; tab-size:2; }
.ascii-card .ascii-cap{ padding:.55rem .9rem .6rem; border-top:1px dashed var(--list-border);
  color:var(--list-muted); font-size:.85em; }
</style>

<script id="LIST_BEAUTY_V2_SCRIPT">
(()=>{'use strict';
if(window.__LIST_BEAUTY_V2__) return; window.__LIST_BEAUTY_V2__=true;

const q=(s,r=document)=>[...r.querySelectorAll(s)];

const wrapLists=(root=document)=>{
  const lists = q('ul,ol',root).filter(el=>{
    if(el.closest('nav,menu,.no-beauty,.editor,.toolbar')) return false;
    if(el.classList.contains('ul-neo')||el.classList.contains('ol-neo')) return false; // j√° cuidado
    return true;
  });
  for(const el of lists){
    const isOL = el.tagName==='OL';
    el.classList.add(isOL?'ol-neo':'ul-neo');
    // preserva estilos existentes do usu√°rio
    if(!el.parentElement.classList.contains('list-card')){
      const wrap = document.createElement('div');
      wrap.className='list-card';
      el.replaceWith(wrap); wrap.appendChild(el);
    }
  }
};

const asciiScore = t=>{
  const box=/[‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚ï≠‚ïÆ‚ï∞‚ïØ‚ïê‚ï¨‚ï†‚ï£‚ï¶‚ï©]+/g, grid=/[-_=+*#\\/|]{3,}/g;
  const L=t.split('\n'); let h=0;
  for(const ln of L){ if(box.test(ln)||grid.test(ln)||ln.trim().startsWith('> ')) h++; }
  return h>=Math.max(2,Math.ceil(L.length*0.2));
};

const enhanceASCII=(root=document)=>{
  const cand=new Set([...q('pre',root),...q('code.language-text, code[class*="language-plaintext"]',root)]);
  q('p',root).forEach(p=>{ const x=p.innerText||''; if(x.includes('\n')&&asciiScore(x)) cand.add(p); });
  for(const el of cand){
    if(el.closest('.ascii-card,.no-beauty')) continue;
    const txt=(el.innerText||'').trim(); if(!asciiScore(txt)) continue;
    const fig=document.createElement('figure'); fig.className='ascii-card';
    const pre=document.createElement('pre'); pre.textContent=txt; fig.appendChild(pre);
    if(!el.closest('pre')){ const fc=document.createElement('figcaption'); fc.className='ascii-cap'; fc.textContent='ASCII ‚Ä¢ renderizado em bloco'; fig.appendChild(fc); }
    el.replaceWith(fig);
  }
};

/* Heur√≠stica opcional: se o UL j√° tiver data-bullet="dash" ou class style-dash, mant√©m.
   Caso N√ÉO tenha, deixamos como diamante (padr√£o), para n√£o interferir nos teus looks. */
const applyDashCapsuleByAttr=(root=document)=>{
  q('ul.ul-neo',root).forEach(ul=>{
    if(ul.matches('.style-dash,[data-bullet="dash"]')) return;
    // n√£o for√ßa nada; o usu√°rio decide via classe/atributo
  });
};

const run=(ctx=document)=>{
  wrapLists(ctx);
  enhanceASCII(ctx);
  applyDashCapsuleByAttr(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'list-ascii-beauty-v2', priority:95});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script>
<!-- ============ /LIST/ASCII BEAUTY PATCH ‚Äî V2 ============ -->


<script id="PATCH_TITLES_ESCAPE_SETEXT_V1">
(()=>{'use strict';
const esc = s => String(s||'')
  .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

function applySetext(lines,i){
  // Detecta "T√≠tulo\n=====" (H1) ou "Subt√≠tulo\n-----" (H2)
  if(i+1 < lines.length){
    const next = lines[i+1].trim();
    if(/^=+$/.test(next)) return { level: 1, text: lines[i].trim(), skip: 2 };
    if(/^-+$/.test(next)) return { level: 2, text: lines[i].trim(), skip: 2 };
  }
  return null;
}

// ------- Flat: sobrescreve helpers do autoBuild se existirem -------
if(typeof window.autoBuild==='function'){
  const abSrc = window.autoBuild.toString();
  if(!abSrc.includes('__TITLES_PATCHED__')){
    const _autoBuild = window.autoBuild;
    window.autoBuild = function(text){
      // wrap original com Setext + escape em H2
      const lines = String(text||'').replace(/\r\n?/g,'\n').split('\n');
      let i=0, rebuilt=[];
      while(i<lines.length){
        const l = lines[i];
        const set = applySetext(lines,i);
        if(set){ // converte para ATX
          rebuilt.push('#'.repeat(set.level)+' '+set.text);
          i+=set.skip; continue;
        }
        rebuilt.push(l); i++;
      }
      // sinaliza patch
      const marker='__TITLES_PATCHED__';
      const saved = window.__current_md;
      window.__current_md = (rebuilt.join('\n'));
      const out = _autoBuild(window.__current_md);
      // corrige todos os <summary><h2> com escape
      document.querySelectorAll('#root details.acc summary h2').forEach(h=>{
        h.innerHTML = esc(h.textContent||'');
      });
      window.__current_md = saved;
      return out;
    }
  }
}

// ------- Nested: adiciona escape no momento de criar se√ß√£o -------
if(typeof window.autoBuildNested==='function'){
  const __origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    const escText = t => esc(t).replace(/\s+#+\s*$/,''); // remove hashes finais
    // monkey-patch: intercepta newSectionAt com escape
    const create = (lvl, title)=>{
      const details = document.createElement('details');
      details.className='acc'; details.open=false;
      const sum=document.createElement('summary');
      sum.innerHTML='<span class="chev"></span><h2>'+ escText(title) +'</h2>';
      const cont=document.createElement('div'); cont.className='sec';
      details.append(sum, cont);
      return {details, cont};
    };
    // roda original, depois faz um passe extra pros h2 existentes
    const out = __origN(text);
    document.querySelectorAll('#root details.acc summary h2').forEach(h=>{
      h.innerHTML = esc(h.textContent||'');
    });
    return out;
  }
}
})();
</script>


<script id="PATCH_MARKDOWNIFY_SMART_V1">
(()=>{'use strict';
function looksTitle(line){
  const t=line.trim();
  if(t.length<80 && /^[A-Z√Å√Ç√É√Ä√â√ä√ç√ì√î√ï√ö√ú√á0-9][^.!?]{2,}$/.test(t)) return true; // curto e sem pontua√ß√£o final
  return false;
}
function isSubtitle(line){
  const t=line.trim();
  return t.length<90 && /[:‚Äî‚Äì-]\s+/.test(t); // ‚ÄúT√≠tulo: subt√≠tulo‚Äù
}
function bulletsNormalize(line){
  // 1) item ‚Üí 1. item ; ‚Ä¢ item ‚Üí - item
  return line
    .replace(/^\s*(\d+)[\)\]]\s+/,'$1. ')
    .replace(/^\s*[‚Ä¢¬∑]\s+/,'- ');
}
function markdownifyPlain(text){
  const L=String(text||'').replace(/\r\n?/g,'\n').split('\n');
  if(/^\s*#\s+/.test(text)) return text; // j√° tem H1
  let out=[], seenH1=false, i=0;
  while(i<L.length){
    let line=L[i];

    // HR por longos tra√ßos
    if(/^\s*[‚Äî‚Äì-]{6,}\s*$/.test(line)){ out.push(''); out.push('---'); out.push(''); i++; continue; }

    // t√≠tulo/subt√≠tulo heur√≠stico
    if(!seenH1 && looksTitle(line)){
      out.push('# '+line.trim()); out.push(''); seenH1=true; i++; continue;
    }
    if(isSubtitle(line) && seenH1){
      out.push('## '+line.trim()); out.push(''); i++; continue;
    }

    // listas simples e numeradas
    line = bulletsNormalize(line);

    // ‚ÄúTermo: valor‚Äù vira lista de defini√ß√£o simples ‚Üí callout
    const def = line.match(/^\s*([A-Z√Å√Ç√É√Ä√â√ä√ç√ì√î√ï√ö√ú√á].{1,40}):\s+(.+)$/);
    if(def){ out.push(':'+def[1]+' ‚Äî '+def[2]); i++; continue; }

    // blocos de c√≥digo heur√≠sticos (muitas chaves/`;`)
    if(/[{;}=].{0,}$/.test(line) && (line.includes('function')||line.includes('=>'))){
      const buf=[line]; i++;
      while(i<L.length && L[i].trim()){
        buf.push(L[i]); i++;
        if(buf.length>1 && /;\s*$/.test(buf[buf.length-1])) break;
      }
      out.push('```js'); out.push(...buf); out.push('```'); out.push('');
      continue;
    }

    out.push(line); i++;
  }
  return out.join('\n');
}

if(typeof window.preprocessMD==='function'){
  const __orig = window.preprocessMD;
  window.preprocessMD = function(text){
    let t=String(text||'');
    // Se n√£o h√° nenhum header e parece ‚Äútexto corrido‚Äù, aplica markdownify
    const lacksHeaders = !/^\s*#{1,6}\s+/m.test(t) && !/^\s*\S+\n[-=]{3,}\s*$/m.test(t);
    const manyWords = (t.match(/\S+/g)||[]).length>40;
    if(lacksHeaders && manyWords) t = markdownifyPlain(t);
    return __orig(t);
  }
}
})();
</script>



<script id="CSS_INNER_SAFE_V2">
(()=>{'use strict';
const STYLE_ID='INLINE_CSS_RENDER_SAFE_V2';
function appendSafe(css){
  if(!css || !css.trim()) return;
  let s=document.getElementById(STYLE_ID);
  if(!s){ s=document.createElement('style'); s.id=STYLE_ID; document.head.appendChild(s); }
  s.appendChild(document.createTextNode('\n'+css));
}
window.CSS_INNER_SAFE = {
  applyFromDOM(root=document){
    let css='';
    root.querySelectorAll('style[data-inline]').forEach(el=>{
      const t=(el.textContent||'').trim(); if(t) css+='\n'+t;
    });
    appendSafe(css);
  },
  applyFromHTML(html){
    if(!html) return;
    // s√≥ <style data-inline>‚Ä¶</style>
    const re=/<style[^>]*\bdata-inline\b[^>]*>([\s\S]*?)<\/style>/gi; let m, css='';
    while((m=re.exec(html))) css+='\n'+(m[1]||'');
    appendSafe(css);
  }
};
document.addEventListener('DOMContentLoaded',()=> CSS_INNER_SAFE.applyFromDOM());
})();
</script>

<script id="KATEX_AUTORUN_AFTER_BUILD_V1">
(()=>{'use strict';
function loadOnceCSS(href,id){return new Promise(ok=>{ if(document.getElementById(id)) return ok();
  const l=document.createElement('link'); l.id=id; l.rel='stylesheet'; l.href=href; l.onload=ok; document.head.appendChild(l); });}
function loadOnceJS(src,id){return new Promise(ok=>{ if(document.getElementById(id)) return ok();
  const s=document.createElement('script'); s.id=id; s.src=src; s.defer=true; s.onload=ok; document.head.appendChild(s); });}
async function ensureKaTeX(){ if(window.renderMathInElement) return;
  const CDN="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist";
  await loadOnceCSS(`${CDN}/katex.min.css`,'katex_css');
  await loadOnceJS(`${CDN}/katex.min.js`,'katex_js');
  await loadOnceJS(`${CDN}/contrib/auto-render.min.js`,'katex_auto_js');
}
async function run(root){
  await ensureKaTeX();
  if(typeof window.KaTeXRender==='function') return window.KaTeXRender(root||document.body);
  if(window.renderMathInElement) window.renderMathInElement(root||document.body,{
    delimiters:[
      {left:"$$",right:"$$",display:true},
      {left:"\$begin:math:display$",right:"\\$end:math:display$",display:true},
      {left:"$", right:"$", display:false},
      {left:"\$begin:math:text$", right:"\\$end:math:text$", display:false},
    ],
    throwOnError:false,
    ignoredTags:["script","noscript","style","textarea","code","pre"]
  });
}
// envelopa os builders
['autoBuild','autoBuildNested'].forEach(name=>{
  const f=window[name];
  if(typeof f==='function' && !f.__kxKaTeXWrapped){
    window[name]=function(text){ const out=f(text); run(document.getElementById('root')); return out; }
    window[name].__kxKaTeXWrapped=true;
  }
});
})();
</script>

<style> #fab .menu [data-action="katex"]{ display:none !important; }</style>


<!-- ============ TEXT BEAUTY & INTERACTION PATCH ‚Äî V3 (aditivo) ============ -->
<style id="TEXT_BEAUTY_V3">
:root{
  --txt-card: color-mix(in oklab, var(--panel, #0e1220) 92%, black);
  --txt-bd: color-mix(in oklab, var(--ink, #e8ecf6) 16%, transparent);
  --txt-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px var(--txt-bd);
  --chip-bg: linear-gradient(42deg, var(--grad-a, #7effa1), var(--grad-b, #67e6ff));
  --chip-ink: #000;
  --paren-ink: color-mix(in oklab, var(--ink, #e8ecf6) 92%, white);
}

/* Tipografia base do texto corrido (aplicamos quando detectado bloco .flow-text) */
.flow-text p{
  text-wrap: pretty;
  line-height: 1.65;
  letter-spacing: .01em;
  margin: .65rem 0;
  hyphens: auto;
}

/* Heading leve detectado por ‚ÄúTitulo:‚Äù */
.flow-text .kv-head{
  font-weight: 800;
  letter-spacing:.02em;
  margin: 1.2rem 0 .4rem;
}

/* Par√™nteses ‚Üí realce sutil */
.span-paren{
  padding: .05rem .35rem;
  border-radius: .55rem;
  border: 1px solid var(--txt-bd);
  color: var(--paren-ink);
  background: color-mix(in oklab, var(--txt-card) 86%, transparent);
}

/* Chips (colchetes) clic√°veis */
.chip, .chip-btn{
  display:inline-grid; place-items:center;
  padding:.25rem .6rem; border-radius:999px;
  background: var(--chip-bg); color: var(--chip-ink);
  font-weight: 700; letter-spacing:.02em;
  box-shadow: 0 2px 10px rgba(0,0,0,.35);
  cursor: pointer; user-select: none;
}
.chip + .chip{ margin-left:.35rem; }

/* Pergunta ‚Üí card */
.q-card{
  background: var(--txt-card);
  border: 1px solid var(--txt-bd);
  box-shadow: var(--txt-shadow);
  border-radius: 14px;
  padding: .85rem 1rem;
  margin: .9rem 0;
  display:grid; grid-template-columns:auto 1fr; gap:.65rem; align-items:start;
}
.q-card .q-ico{
  inline-size:1.65rem; block-size:1.65rem; border-radius:50%;
  display:grid; place-items:center; font-weight:800; color:#000;
  background: var(--chip-bg);
}
.q-card .q-body{ line-height:1.55; }

/* Overlay de copiar nas listas (usa .list-card do patch anterior) */
.list-card{ position:relative; }
.list-card .copy-badge{
  position:absolute; top:.35rem; right:.35rem;
  font-size:.8rem; padding:.2rem .45rem; border-radius:999px;
  background: color-mix(in oklab, #fff 12%, var(--txt-card));
  border: 1px solid var(--txt-bd);
  color: var(--ink, #e8ecf6); opacity:.65; transition:.2s; user-select:none;
}
.list-card:hover .copy-badge{ opacity:1; }

/* √Årea que receber√° HTML ‚Äúdesescapado‚Äù */
.raw-html-card{
  background: var(--txt-card); border: 1px dashed var(--txt-bd);
  border-radius: 14px; padding: .85rem 1rem; margin: .9rem 0;
}
.raw-html-card .raw-note{ color: color-mix(in oklab, var(--ink) 62%, transparent); font-size:.85em; margin-bottom:.35rem; }
</style>

<script id="TEXT_BEAUTY_V3_SCRIPT">
(()=>{'use strict';
if(window.__TEXT_BEAUTY_V3__) return; window.__TEXT_BEAUTY_V3__=true;

/* Utilit√°rios */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>[...r.querySelectorAll(s)];
const esc=(s)=>s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/* 0) Toggle edi√ß√£o r√°pida */
let EDIT_ON=false;
const toggleEdit=()=>{
  EDIT_ON=!EDIT_ON;
  document.body.toggleAttribute('data-edit', EDIT_ON);
  const host = document.getElementById('CONTENT') || document.querySelector('main, article, .render, .reader, body');
  if(host) host.contentEditable = EDIT_ON ? 'plaintext-only' : 'false';
};
document.addEventListener('keydown',e=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='e'){ e.preventDefault(); toggleEdit(); }
});

/* 1) Key:Value negrito (palavra:) + par√™nteses + chips [ ]
   - roda apenas em blocos de texto (p, li) e n√£o mexe dentro de code/pre */
const processInline = (root=document)=>{
  const targets = $$('p, li, h1, h2, h3, h4, h5, h6', root).filter(n=>!n.closest('pre, code, .no-beauty'));
  const rxKV = /(^|\s)([A-Za-z√Ä-√ø0-9_]+):(?=\s|$)/g; // Palavra:
  const rxParen = /\(([^\n)]+)\)/g;                  // ( ‚Ä¶ )
  const rxChip  = /\[\[([^[\]]+)\]\]|\[([^[\]]+)\]/g; // [[a]] | [a]

  for(const el of targets){
    // evita processar m√∫ltiplas vezes
    if(el.dataset.inlineProcessed==='1') continue;
    el.dataset.inlineProcessed='1';

    const html = el.innerHTML;
    if(/<pre|<code|contenteditable/i.test(html)) continue;

    let out = html;

    // 1. Palavra:  ‚Üí <strong>
    out = out.replace(rxKV, (m, sp, key)=> `${sp}<strong class="kv-key">${key}:</strong>`);

    // 2. ( ... )   ‚Üí span-paren
    out = out.replace(rxParen, (m, inside)=> `<span class="span-paren">(${inside})</span>`);

    // 3. [ ... ] / [[ ... ]]  ‚Üí chip/chip-btn
    out = out.replace(rxChip, (m, dbl, sgl)=>{
      const label = (dbl||sgl||'').trim();
      return `<span class="${dbl?'chip-btn':'chip'}" data-chip="${esc(label)}">${esc(label)}</span>`;
    });

    el.innerHTML = out;
  }
};

/* 2) Perguntas ‚Üí .q-card (frases que terminam com '?') */
const processQuestions=(root=document)=>{
  const paras = $$('p', root).filter(n=>!n.closest('.q-card, pre, code, .no-beauty'));
  for(const p of paras){
    const txt = (p.innerText||'').trim();
    if(txt.endsWith('?') && !p.dataset.qProcessed){
      p.dataset.qProcessed='1';
      const wrap=document.createElement('div'); wrap.className='q-card';
      wrap.innerHTML = `<div class="q-ico">?</div><div class="q-body">${esc(txt)}</div>`;
      p.replaceWith(wrap);
    }
  }
};

/* 3) Flow text: melhora texto corrido, cria heading leve se linha for "Algo:" sozinha */
const beautifyFlow=(root=document)=>{
  const container = root.querySelector('.flow-text') || root; // se j√° tiver classe, usa; sen√£o aplica heur√≠stica suave
  $$('p', container).forEach(p=>{
    const t=(p.innerText||'').trim();
    if(/^[^:\n]{3,}:\s*$/.test(t)){ // linha que termina com ":" vira heading leve
      p.classList.add('kv-head');
    }
    // Quebra par√°grafos absurdamente longos em dois (heur√≠stica)
    if(t.length>600 && t.includes('. ')){
      const mark = t.indexOf('. ', Math.floor(t.length/2));
      if(mark>0){
        const a=t.slice(0, mark+1), b=t.slice(mark+1);
        const p2=p.cloneNode(); p2.textContent=b.trim();
        p.textContent=a.trim();
        p.insertAdjacentElement('afterend', p2);
      }
    }
  });
};

/* 4) Listas copi√°veis: badge + click copy */
const enableCopyLists=(root=document)=>{
  const lists = $$('.list-card', root);
  for(const card of lists){
    if(card.querySelector('.copy-badge')) continue;
    const badge = document.createElement('div');
    badge.className='copy-badge'; badge.textContent='copiar';
    card.appendChild(badge);
    card.addEventListener('click', e=>{
      // evita copiar quando clicou em link/bot√£o dentro
      if(e.target.closest('a,button,.chip,.chip-btn')) return;
      const txt = [...card.querySelectorAll('li')].map(li=>li.innerText.trim()).join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        badge.textContent='copiado!'; setTimeout(()=>badge.textContent='copiar',1200);
      });
    }, {passive:true});
  }
};

/* 5) HTML/SVG pass-through
   - ```html-raw ... ``` ‚Üí renderiza
   - <div data-raw-html>‚Ä¶(escapado)‚Ä¶</div> ‚Üí renderiza
*/
const renderRawHTML=(root=document)=>{
  // code fence transform
  $$('pre code', root).forEach(code=>{
    const cls = (code.className||'').toLowerCase();
    if(cls.includes('language-html-raw') || cls.includes('lang-html-raw')){
      const raw = code.textContent;
      const box = document.createElement('div');
      box.className='raw-html-card';
      box.innerHTML = `<div class="raw-note">HTML/SVG renderizado a partir de bloco <code>html-raw</code></div>`;
      const slot = document.createElement('div');
      slot.className='raw-slot';
      // injeta SEM esc, assumindo que o autor confia no conte√∫do
      slot.innerHTML = raw;
      box.appendChild(slot);
      const pre = code.closest('pre');
      pre.replaceWith(box);
    }
  });

  // <div data-raw-html>‚Ä¶</div>
  $$('div[data-raw-html]', root).forEach(div=>{
    const raw = div.textContent; // assume texto escapado pelo md
    const box = document.createElement('div'); box.className='raw-html-card';
    const slot = document.createElement('div'); slot.className='raw-slot';
    slot.innerHTML = raw;
    box.appendChild(slot);
    div.replaceWith(box);
  });
};

/* 6) Delega√ß√£o de cliques para chips (colchetes) */
document.addEventListener('click', e=>{
  const chip = e.target.closest('.chip, .chip-btn');
  if(chip){
    const label = chip.dataset.chip||chip.textContent.trim();
    // dispara um evento customizado para teu bus/orquestrador
    const ev = new CustomEvent('chip:click', {detail:{label, source:'text-beauty-v3'}});
    document.dispatchEvent(ev);
  }
}, {passive:true});

/* 7) Orquestra√ß√£o */
const run=(ctx=document)=>{
  processInline(ctx);
  processQuestions(ctx);
  beautifyFlow(ctx);
  enableCopyLists(ctx);
  renderRawHTML(ctx);
};

if(window.__RENDERBUS__?.on){
  window.__RENDERBUS__.on('after', run, {name:'text-beauty-v3', priority: 96});
}else{
  (document.readyState==='loading') ? document.addEventListener('DOMContentLoaded',()=>run(document)) : run(document);
  new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&run(n))))
    .observe(document.body,{childList:true,subtree:true});
}
})();
</script>
<!-- ============ /TEXT BEAUTY & INTERACTION PATCH ‚Äî V3 ============ -->

<script id="KOBLLUX_HOTFIX_BUNDLE_V1">
(()=>{'use strict';
if (window.__KOBLLUX_HOTFIX_BUNDLE_V1__) return;
window.__KOBLLUX_HOTFIX_BUNDLE_V1__ = true;

/* ========= Helpers ========= */
const $ = (q, r=document)=>r.querySelector(q);

/* Biblioteca (Stacks) */
function _libLoad(){ try{ return JSON.parse(localStorage.getItem('tl_library_v1')||'[]'); }catch{ return []; } }
function _libSave(arr){ localStorage.setItem('tl_library_v1', JSON.stringify(arr)); }
function _upsertDoc(doc){
  const arr = _libLoad();
  const idx = arr.findIndex(d => d.id === doc.id);
  if (idx >= 0) arr[idx] = doc; else arr.unshift(doc);
  _libSave(arr);
}

/* Render helper (n√£o quebra se autoBuild n√£o existir) */
async function _openText(md){
  window.__current_md = md || '';
  if (typeof autoBuild === 'function') autoBuild(md);
}

/* ========= 1) Exportar .md (iOS/Safari-safe) ========= */
window.exportMD = function(){
  const md = (typeof buildMDFromDOM === 'function' ? buildMDFromDOM() : (window.__current_md || ''));
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
  const a = document.createElement('a');
  const base = (window.__current_title || 'export').replace(/[\\\/:*?"<>|]+/g,'-').slice(0,80) || 'export';
  a.download = base + '.md';
  a.href = URL.createObjectURL(blob);
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1200);
  if (window.toast) toast('.md exportado');
};

/* ========= 2) Upload cria novo contexto (sem sobrescrever) ========= */
const _fi = document.getElementById('fileInput');
if (_fi && !_fi.dataset._ctxFix){
  _fi.dataset._ctxFix = '1';
  _fi.addEventListener('change', async (e)=>{
    const f = e.target.files?.[0];
    if (!f) return;
    const prev = document.getElementById('filePreview');
    if (prev) prev.textContent = 'Lendo ' + f.name + '...';

    // Zera o contexto para evitar sobrescrita no Salvar
    window.__current_doc_id = null;
    window.__current_title  = (f.name || 'Documento').replace(/\.(pdf|txt|md|markdown|html|htm)$/i, '');

    // PDF (se pdfjsLib estiver dispon√≠vel)
    if (/\.(pdf)$/i.test(f.name) && window.pdfjsLib){
      try{
        const buf = await f.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
        let txt = '';
        for (let i = 1; i <= pdf.numPages; i++) {
          const p = await pdf.getPage(i);
          const c = await p.getTextContent();
          txt += c.items.map(it => it.str).join(' ') + '\n';
        }
        await _openText(txt);
      }catch(err){
        console.warn('[upload pdf] falhou:', err);
        await _openText(''); if (window.toast) toast('Falha ao ler PDF');
      }
    } else {
      // Demais extens√µes: l√™ como texto
      const txt = await f.text();
      await _openText(txt);
    }
  }, { capture: true });
}

/* ========= 3) Salvar vira update quando h√° __current_doc_id ========= */
(function(){
  window.saveCurrent = function(){
    const md = (typeof getCurrentMarkdown === 'function' ? getCurrentMarkdown() : (window.__current_md || ''));
    const ti = document.getElementById('docTitle');
    const titleFromH1 = md.match(/^\s*#\s+(.+)$/m)?.[1];
    const title = (ti && ti.value.trim()) || titleFromH1 || (window.__current_title || 'Sem t√≠tulo');
    const now = new Date().toISOString();

    const arr = _libLoad();
    const existing = arr.find(d => d.id === window.__current_doc_id);
    const id = window.__current_doc_id || (self.crypto?.randomUUID ? ('doc_' + crypto.randomUUID()) : ('doc_' + Date.now()));

    const doc = {
      id,
      title,
      md,
      bytes: md.length,
      createdAt: existing?.createdAt || now,
      updatedAt: now
    };

    _upsertDoc(doc);
    window.__current_doc_id = id;   // fixa o contexto
    window.__current_title  = title;
    localStorage.setItem('tl_last_doc_id', id);
    if (window.toast) toast(existing ? 'Atualizado em Stacks' : 'Salvo em Stacks');
  };
})();

/* ========= 4) Patches de a√ß√µes (Stacks) ========= */
if (window.ACTIONS && !window.ACTIONS.__koblluxFixed){
  // open-doc: abre do acervo e seta contexto para update
  const _oldOpen = window.ACTIONS['open-doc'];
  window.ACTIONS['open-doc'] = function(el){
    const id = el?.dataset?.id;
    const doc = _libLoad().find(d => d.id === id);
    if (!doc) return;
    window.__current_doc_id = id;
    window.__current_title  = doc.title || '';
    window.__current_md     = doc.md || '';
    _openText(doc.md);
  };

  // md-doc: exporta .md (iOS-safe)
  window.ACTIONS['md-doc'] = function(el){
    const id = el?.dataset?.id;
    const doc = _libLoad().find(d => d.id === id);
    if (!doc) return;
    const blob = new Blob([doc.md||''], { type:'text/markdown;charset=utf-8' });
    const a = document.createElement('a');
    a.download = (doc.title || 'documento') + '.md';
    a.href = URL.createObjectURL(blob);
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1200);
  };

  window.ACTIONS.__koblluxFixed = true;
}

/* ========= 5) Opcional: limpar SW + caches (PWA hard refresh) ========= */
window.forceHardRefresh = function(){
  (async()=>{
    try{
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k)));
    }catch{}
    if ('serviceWorker' in navigator){
      try{
        const regs = await navigator.serviceWorker.getRegistrations();
        await Promise.all(regs.map(r => r.unregister()));
      }catch{}
    }
    location.reload();
  })();
};
})();
</script>


<script id="KOBLLUX_TTS_PATCH_V1">
(()=>{'use strict';
if(window.__KOBLLUX_TTS_PATCH_V1__) return;
window.__KOBLLUX_TTS_PATCH_V1__ = true;

const synth = window.speechSynthesis;
let speaking = false, paused = false;
let currentUtter = null;

/* ===== Bot√£o ON/OFF ===== */
const fab = document.createElement('button');
fab.id = 'ttsToggle';
fab.textContent = 'üîä';
fab.style.cssText = `
position:fixed;top:66px;right:16px;z-index:99999;
border:none;border-radius:50%;width:32px;height:32px;
font-size:24px;cursor:pointer;
background:linear-gradient(42deg,#0f0,#0ff);
box-shadow:0 0 12px rgba(0,255,255,.4);
`;
fab.title = 'TTS: desligado';
document.body.appendChild(fab);

/* ===== Fun√ß√µes ===== */
function readAll(){
  if(speaking) return;
  const area = document.querySelector('#renderArea, main, article, #book') || document.body;
  const blocks = [...area.querySelectorAll('h1,h2,h3,p,li,blockquote,section,div')]
    .map(x => x.innerText.trim()).filter(Boolean);
  if(!blocks.length){ toast?.('Nada para ler'); return; }

  speaking = true; paused = false;
  fab.style.background = 'linear-gradient(42deg,#0ff,#0f0)';
  fab.title = 'TTS: ligado';

  let i = 0;
  const readNext = ()=>{
    if(!speaking || i>=blocks.length){ stopTTS(); return; }
    const text = blocks[i];
    currentUtter = new SpeechSynthesisUtterance(text);
    currentUtter.lang = 'pt-BR';
    currentUtter.rate = 1.0;
    currentUtter.pitch = 1.0;
    currentUtter.volume = 1.0;

    const el = area.querySelectorAll('h1,h2,h3,p,li,blockquote,section,div')[i];
    if(el){ el.style.outline='2px solid #0ff'; el.scrollIntoView({behavior:'smooth',block:'center'}); }

    currentUtter.onend = ()=>{
      if(el) el.style.outline='none';
      i++; readNext();
    };
    synth.speak(currentUtter);
  };
  readNext();
}

function stopTTS(){
  if(currentUtter) synth.cancel();
  speaking = false; paused = false;
  fab.style.background = 'linear-gradient(42deg,#0f0,#0ff)';
  fab.title = 'TTS: desligado';
}

/* ===== Bot√£o toggle ===== */
fab.addEventListener('click', ()=>{
  if(!speaking){ readAll(); }
  else{ stopTTS(); toast?.('Leitura parada'); }
});

/* ===== Teclas r√°pidas (opcional) ===== */
document.addEventListener('keydown', e=>{
  if(e.key==='F2'){ fab.click(); } // F2 = liga/desliga
});

})();
</script>



 
<script type="module">
  import { applyRGX } from './js/patches/MAP_RGX_v3_KOBLLUX.mjs';

  document.addEventListener('DOMContentLoaded', () => {
    // raiz onde o markdown √© renderizado
    const root =
      document.querySelector('#reader') ||
      document.querySelector('#app')    ||
      document.body;

    // marca o root pra anima√ß√£o do TTS e estilo local
    root.dataset.koblluxRoot = '1';

    // ativa o engine (chips, callouts, bot√µes, IA, TTS)
    applyRGX(root);
  });
</script>

 



<!-- MD Smart Generator ¬∑ Mon√≥lito BUGAD√ÉO v3 -->
<script type="module">
/* ============================================================
   Monolithic MD Generator (BUGAD√ÉO) ‚Äî v3
   - Default: "Glitch Mode" ON (windows-1252 decode)
   - Toggle Glitch/UTF-8 sem reupload (mant√©m bytes em cache)
   - Upload ‚Üí textarea (staging), s√≥ render se pedir
   - Converter ‚Üí MD / Converter+Gerar
   - Callouts inline ::info/::warn/::aside
   - Tabela pipe ‚Üí lista-tabela (linhas "- "), coluna-chave ‚Üí (par√™nteses)
   ============================================================ */
let MDGEN_GLITCH_MODE = true;
let __mdgen_lastBytes = null;   // ArrayBuffer dos bytes do √∫ltimo upload
let __mdgen_filename  = null;

function tryFindTextarea(){
  return document.querySelector('#srcText, #src, textarea[name="src"], textarea');
}

function decodeBytes(ab, label){
  try{
    const dec = new TextDecoder(label || (MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8'), {fatal:false});
    return dec.decode(new Uint8Array(ab));
  }catch(e){
    console.warn('Decoder falhou, fallback utf-8', e);
    return new TextDecoder('utf-8').decode(new Uint8Array(ab));
  }
}

function setTextarea(text){
  const ta = tryFindTextarea();
  if(!ta) return;
  ta.value = text;
  ta.focus();
  ta.setSelectionRange(0, Math.min(text.length, 2000));
}

function generateSmartMD(input, opts={}){
  const o = Object.assign({ title:'Documento Convertido', addHeaderButtons:true, addMeta:true }, opts||{});
  let txt = String(input||'').replace(/\r\n?/g,'\n').replace(/[‚Äú‚Äù]/g,'"').replace(/[‚Äô‚Äò]/g,"'").replace(/'''/g,'```');
  if(!/^#\s/m.test(txt)){ txt = `# ${o.title}\n\n` + txt; }

  const lines = txt.split('\n'), OUT=[]; let i=0;
  const KEY_WARN=/\b(aten√ß(√£|a)o|cuidado|risco|quebra|bug|perigo)\b/i;
  const KEY_INFO=/\b(nota|observa(√ß|c)[a√£]o|info|dica|lembrete)\b/i;
  const KEY_ASIDE=/\b(contexto|bastidor|extra|observa(√ß|c)[a√£]o lateral)\b/i;
  const KEY_OK=/\b(sucesso|ok|pronto|feito)\b/i;
  const KEY_Q=/\?\s*$/;
  function push(s){ OUT.push(s); }

  while(i<lines.length){
    let line=lines[i];
    if(/^\s*```/.test(line)){ push(line); i++; while(i<lines.length && !/^\s*```/.test(lines[i])) push(lines[i++]); if(i<lines.length) push(lines[i++]); continue; }
    const mFn=line.match(/^\s*["‚Äú‚Äù](.+function\s+[a-zA-Z_$][\w$]*\s*\([^)]*\)\s*\{.*\})["‚Äú‚Äù]\s*$/);
    if(mFn){ push('```js'); push(mFn[1]); push('```'); i++; continue; }
    const plain=line.trim();
    if(plain){
      if(KEY_WARN.test(plain)){  push(`::warn ${plain}`);  i++; continue; }
      if(KEY_ASIDE.test(plain)){ push(`::aside ${plain}`); i++; continue; }
      if(KEY_INFO.test(plain)){  push(`::info ${plain}`);  i++; continue; }
      if(KEY_OK.test(plain)){    push(`: ${plain}`);       i++; continue; }
      if(KEY_Q.test(plain)){     push(`? ${plain}`);       i++; continue; }
    }
    push(line); i++;
  }
  let md=OUT.join('\n');

  // Normaliza callouts multiline ‚Üí linha √∫nica
  md = md.replace(
    /(^|\n)::(info|warn|aside|pulse|loop)\s*\n+([^:\n>][^\n]+(?:\n(?!::(info|warn|aside|pulse|loop)\b)[^\n]+)*)/gi,
    (m, pre, kind, body)=>`${pre}::${kind} ${body.replace(/\s*\n\s*/g,' ').trim()}`
  );

  // Tabelas pipe ‚Üí lista-tabela (com coluna-chave opcional)
  md = md.replace(
    /(^|\n)\|([^\n]+)\|\n\|([ :\-|]+)\|\n((?:\|[^\n]+\|\n?)+)/g,
    (m, pre, headerRow, sepRow, bodyRows) => {
      const headers = headerRow.split('|').map(s=>s.trim());
      let keyIdx = -1;
      for(let i=0;i<headers.length;i++){
        const h=headers[i];
        if(/\(key\)|\[key\]|\*$/i.test(h) || /\b(chave|key)\b/i.test(h)){
          keyIdx=i; headers[i]=h.replace(/\s*(\(key\)|\[key\]|\*)\s*$/i,''); break;
        }
      }
      const body = bodyRows.trim().split('\n').map(r=>r.trim()).filter(Boolean).map(r=>{
        const cells = r.replace(/^\|/,'').replace(/\|$/,'').split('|').map(s=>s.trim());
        if(keyIdx>=0 && keyIdx<cells.length){ const c=cells[keyIdx]; cells[keyIdx]=/^\(.*\)$/.test(c)?c:`(${c})`; }
        return '- | '+cells.join(' | ')+' |';
      }).join('\n');
      return `${pre}|${headers.join(' | ')}|\n|${sepRow}|\n${body}\n`;
    }
  );

  if(o.addHeaderButtons){
    md = md.replace(/^#\s+.+$/m, (h1)=>`${h1}\n\n[[btn:gerar|Gerar]] [[btn:nested|Gerar (aninhado)]] [[btn:md|Salvar .md]] [[btn:pdf|Imprimir PDF]]\n`);
  }
  if(o.addMeta){ md += `\n\n::aside Documento gerado por MD Smart Generator (BUGAD√ÉO v3)`;}
  return md;
}

// Exportador .md no padr√£o "lista-tabela"
function installExportMD_ListTable(){
  if(window.exportMD) return;
  window.exportMD = function(){
    const root=document.getElementById('root'); if(!root){ alert('Sem root'); return; }
    const parts=[];
    root.querySelectorAll('details.acc').forEach((d,secIdx)=>{
      const h=d.querySelector('summary h2'); if(h){ const mark='#'.repeat(secIdx===0?1:2); parts.push(`${mark} ${h.textContent.trim()}`); }
      d.querySelectorAll('.sec > *').forEach(el=>{
        if(el.matches('p')) parts.push(el.innerText.replace('Copiar','').trim());
        else if(el.matches('blockquote')) parts.push('> '+el.innerText.replace('Copiar','').trim());
        else if(el.matches('.callout')){
          const t=el.className.match(/\b(info|warn|tip|note|success|danger|aside|question)\b/);
          const kind=t?(t[1]==='note'?':': t[1]==='question'?'?': t[1]==='aside'?'::aside':'::'+t[1]):': ';
          parts.push(`${kind} `+el.innerText.replace('Copiar','').trim());
        }else if(el.matches('pre.md-code')){
          const code=el.querySelector('code')?.textContent||''; parts.push('```\n'+code+'\n```');
        }else if(el.matches('table.md-table')){
          const rows=[...el.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.innerText.trim()));
          if(rows.length){
            parts.push('| '+rows[0].join(' | ')+' |');
            parts.push('| '+rows[0].map(()=> '---').join(' | ')+' |');
            rows.slice(1).forEach(r=> parts.push('- | '+r.join(' | ')+' |'));
          }
        }else if(el.matches('ul,ol')){
          el.querySelectorAll('li').forEach(li=>parts.push('- '+li.innerText.trim()));
        }
      });
    });
    const blob=new Blob([parts.join('\n\n')],{type:'text/markdown'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='export_listTable.md'; a.click(); URL.revokeObjectURL(a.href);
    (window.toast||console.log)('.md exportado (lista-tabela)');
  };
}

// Upload ‚Üí staging: L√ä COMO BYTES e decodifica com windows-1252 (Glitch ON) ou utf-8 (Glitch OFF)
function installUploadStagingBugadao(opts={}){
  const o = Object.assign({inputSelector:'input[type=file], #upload, #fileUpload, .upload-input'}, opts||{});
  const inputs = Array.from(document.querySelectorAll(o.inputSelector));
  const ta = tryFindTextarea();
  inputs.forEach(inp=>{
    if(inp.dataset.mdgenUpload==='1') return;
    inp.dataset.mdgenUpload='1';
    inp.addEventListener('change', (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if(!f) return;
      __mdgen_filename = f.name;
      const reader = new FileReader();
      reader.readAsArrayBuffer(f); // bytes puros
      reader.onload = ()=>{
        __mdgen_lastBytes = reader.result;
        const text = decodeBytes(__mdgen_lastBytes, MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8');
        setTextarea(text);
        (window.toast||console.log)(`Upload carregado no input (staging, ${MDGEN_GLITCH_MODE?'GLITCH 1252':'UTF-8'})`);
      };
    }, false);
  });
}

// Monta UI (bot√µes + toggle Glitch)
function mountMDGeneratorUI(){
  const tab=document.querySelector('#tab-text')||document.body;
  if(tab.querySelector('.btn-converter')) return;
  const ta = tryFindTextarea();
  const bar=document.createElement('div'); bar.style.display='flex'; bar.style.gap='8px'; bar.style.marginTop='8px'; bar.style.flexWrap='wrap';

  const b1=document.createElement('button'); b1.className='btn btn-converter'; b1.textContent='Converter ‚Üí MD';
  b1.onclick=()=>{ const raw=(ta&&ta.value)?ta.value:''; const md=generateSmartMD(raw||'# Documento\n\nTexto aqui...'); if(ta){ ta.value=md; ta.focus(); ta.setSelectionRange(0,md.length);} (window.toast||console.log)('Texto convertido para MD'); };

  const b2=document.createElement('button'); b2.className='btn btn-gen-inteligente'; b2.textContent='Converter+Gerar';
  b2.onclick=()=>{ const raw=(ta&&ta.value)?ta.value:''; const md=generateSmartMD(raw||'# Documento\n\nTexto aqui...'); if(typeof window.autoBuild==='function'){ window.autoBuild(md); (window.toast||console.log)('Convertido e renderizado (ARN)'); } else { alert(md);} };

  const wrap=document.createElement('label'); wrap.style.display='inline-flex'; wrap.style.alignItems='center'; wrap.style.gap='6px';
  const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.title='Glitch Mode (windows-1252)';
  const sp=document.createElement('span'); sp.textContent='üòµ‚Äçüí´ Glitch Mode';
  cb.onchange=()=>{
    MDGEN_GLITCH_MODE = cb.checked;
    if(__mdgen_lastBytes){
      const text = decodeBytes(__mdgen_lastBytes, MDGEN_GLITCH_MODE ? 'windows-1252' : 'utf-8');
      setTextarea(text);
      (window.toast||console.log)(`Re-decodificado ${__mdgen_filename||''} ‚Üí ${MDGEN_GLITCH_MODE?'GLITCH 1252':'UTF-8'}`);
    }
  };
  wrap.appendChild(cb); wrap.appendChild(sp);

  bar.appendChild(b1); bar.appendChild(b2); bar.appendChild(wrap);
  tab.appendChild(bar);
}

function autoMountBugadao(){
  mountMDGeneratorUI();
  installUploadStagingBugadao();
  // exportador md
  installExportMD_ListTable();
  console.info('[MD Smart Generator ¬∑ BUGAD√ÉO v3] pronto.');
}
window.addEventListener('DOMContentLoaded', autoMountBugadao);
</script>


<!-- KOBLLUX :: PATCH √öNICO ‚Äî TTS por Blocos (v2 ‚Ä¢ Dock Vertical + Drag + Auto-Wire) -->
<style>
  /* =======================================================================
     KOBLLUX ‚Äî TTS Dock (Nebula Pro + Base Madeira)
     MOBILE-FIRST VERTICAL HARD-LOCK
     ======================================================================= */

  /* Destaque do bloco atual lido */
  [data-tts-current]{
    outline:2px dashed var(--cyan,#4cf);
    background:rgba(76,240,255,.06);
    border-radius:8px;
    transition:background .25s ease, outline .25s ease;
  }

  /* Tokens */
  :root{
    --tts-dock-left: 8px;         /* ajuste livre */
    --tts-dock-bottom: 269px;     /* ajuste livre */
    --tts-gap: 10px;

    --tts-glass-bg: rgba(15,18,28,.38);
    --tts-glass-bd: rgba(255,255,255,.12);
    --tts-glow:     rgba(76,240,255,.85);   /* ciano (Nebula) */
    --tts-ink:      rgba(255,255,255,.92);
    --tts-ink-dim:  rgba(255,255,255,.68);
    --tts-accent:   color-mix(in srgb, #00e28b 55%, var(--tts-glow) 45%); /* Base Madeira + ciano */
  }

  /* Base inline (fallback) */
  .kob-tts-panel{
    display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;margin:.5rem 0
  }
  .kob-tts-panel button{
    padding:.5rem .75rem;
    border:1px solid rgba(255,255,255,.2);
    background:rgba(255,255,255,.05);
    backdrop-filter:saturate(1.2) blur(2px);
    border-radius:10px
  }
  .kob-tts-panel small{opacity:.8}

  /* Dock vertical fixo */
  .kob-tts-panel.is-dock{
    position: fixed;
    left: var(--tts-dock-left);
    bottom: calc(var(--tts-dock-bottom) + env(safe-area-inset-bottom, 0px));
    z-index: 9999;
    display: flex;
    flex-direction: column;
    gap: var(--tts-gap);
    align-items: stretch;

    padding: .6rem;
    border-radius: 16px;
    background: var(--tts-glass-bg);
    border: 1px solid var(--tts-glass-bd);
    -webkit-backdrop-filter: blur(10px) saturate(1.15);
    backdrop-filter: blur(10px) saturate(1.15);
    box-shadow: 0 12px 26px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05);

    touch-action: none; /* habilita drag suave */
    cursor: grab;
  }
  .kob-tts-panel.is-dock.is-dragging{
    cursor: grabbing;
    transition: none !important;
  }

  .kob-tts-panel.is-dock button{
    width: 48px; height: 48px;
    border-radius: 14px;
    display: grid; place-items: center;

    color: var(--tts-ink-dim);
    font-size: 20px; line-height: 1; font-weight: 600;

    border: 1px solid rgba(255,255,255,.18);
    background:
      linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02)) padding-box,
      linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05)) border-box;

    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    cursor: pointer;
    transition: transform .16s ease, box-shadow .16s ease, color .16s ease, background .16s ease;
  }
  .kob-tts-panel.is-dock button:hover{
    transform: translateY(-1px);
    color: var(--tts-ink);
    box-shadow: 0 8px 18px rgba(0,0,0,.32), inset 0 0 0 1px rgba(255,255,255,.10);
  }
  .kob-tts-panel.is-dock button:active{ transform: translateY(0); }

  .kob-tts-panel.is-dock button[aria-pressed="true"]{
    color: var(--tts-ink);
    background:
      radial-gradient(120% 120% at 50% 0%, color-mix(in srgb, var(--tts-glow), transparent 65%) 0%, transparent 60%) padding-box,
      linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.08)) border-box;
    outline: 2px solid color-mix(in srgb, var(--tts-glow) 70%, var(--tts-accent) 30%);
    box-shadow:
      0 0 18px -2px color-mix(in srgb, var(--tts-glow) 70%, var(--tts-accent) 30%),
      0 10px 26px rgba(0,0,0,.38),
      inset 0 0 0 1px rgba(255,255,255,.10);
  }

  /* micro-ripple sem JS */
  .kob-tts-panel.is-dock button::after{
    content:""; position:absolute; inset:0; border-radius:inherit; opacity:0;
    box-shadow: 0 0 0 0 var(--tts-glow);
    transition: box-shadow .4s ease, opacity .4s ease;
  }
  .kob-tts-panel.is-dock button:active::after{
    opacity:.4; box-shadow: 0 0 0 10px transparent;
  }

  .kob-tts-panel.is-dock small[data-tts-status]{
    margin-top: .15rem; font-size: 11px; letter-spacing: .2px;
    opacity: .78; color: var(--tts-ink); max-width: 172px; text-wrap: balance;
  }

  .kob-tts-panel.is-dock button:focus-visible{
    outline: 2px solid var(--tts-accent); outline-offset: 2px;
  }

  @supports not ((backdrop-filter: blur(10px))){
    .kob-tts-panel.is-dock{ background: rgba(20,22,28,.85); }
  }
  @media (prefers-reduced-motion: reduce){
    .kob-tts-panel.is-dock, .kob-tts-panel.is-dock button{ transition: none !important; }
  }
  @media print{ .kob-tts-panel.is-dock{ display:none !important; } }

  /* Espa√ßo opcional no conte√∫do quando o dock existir */
  body.kob-tts-dock-padding{ padding-left: calc(var(--tts-dock-left) + 72px); }
</style>

<script>
(()=>{ // IIFE ‚Äì instala somente uma vez
  if(window.__KOB_TTS_V2_ACTIVE){ console.debug('[KOBLLUX TTS] j√° ativo'); return; }
  window.__KOB_TTS_V2_ACTIVE = true;

  const DOCKED = true;          // true = dock vertical fixo
  const DRAG_ENABLED = true;    // arrastar e lembrar posi√ß√£o
  const POS_KEY = 'kob_tts_dock_pos_v1';

  // ‚Äî‚Äî‚Äî Mitigar conflito com TTS antigo ‚Äî‚Äî‚Äî
  try{
    if('speechSynthesis' in window){ window.speechSynthesis.cancel(); }
    if(window.__tts && typeof window.__tts.stop === 'function'){ try{ window.__tts.stop(); }catch(e){} }
    window.__tts = { set:()=>{}, speak:()=>{}, stop:()=>{} }; // no-op legacy
  }catch(e){}

  const synth = ('speechSynthesis' in window) ? window.speechSynthesis : null;
  if(!synth){ console.warn('[KOBLLUX TTS] SpeechSynthesis n√£o dispon√≠vel'); return; }

  // ‚Äî‚Äî‚Äî Seletores tolerantes para raiz renderizada/analisada ‚Äî‚Äî‚Äî
  const ROOT_SELECTORS = ['#root','[data-analyzer-output]','.analyzer-output','#render','main','.content'];
  const getRoot = ()=> {
    for(const sel of ROOT_SELECTORS){
      const el = document.querySelector(sel);
      if(el) return el;
    }
    return document.body;
  };

  // ‚Äî‚Äî‚Äî UI ‚Äî‚Äî‚Äî
  const ensurePanel = ()=>{
    let wrap = document.querySelector('.kob-tts-panel');
    let btnT = document.getElementById('btn-tts');
    let btnS = document.getElementById('btn-tts-sel');
    let btnX = document.getElementById('btn-tts-stop');
    let btnPrev = document.getElementById('btn-tts-prev');
    let btnNext = document.getElementById('btn-tts-next');
    let status = document.querySelector('[data-tts-status]');

    if(!(btnT && btnS && btnX && status)){
      wrap = document.createElement('div');
      wrap.className = 'kob-tts-panel' + (DOCKED ? ' is-dock' : '');
      wrap.innerHTML = DOCKED
        ? `
          <button id="btn-tts"       type="button" title="Ativar/Desativar leitura cont√≠nua" aria-pressed="false">üîä</button>
          <button id="btn-tts-prev"  type="button" title="Bloco anterior">‚óÄ</button>
          <button id="btn-tts-next"  type="button" title="Pr√≥ximo bloco">‚ñ∂</button>
          <button id="btn-tts-sel"   type="button" title="Ler apenas sele√ß√£o">‚úÇÔ∏é</button>
          <button id="btn-tts-stop"  type="button" title="Parar voz">‚ñ†</button>
          <small data-tts-status>Pronto.</small>
        `
        : `
          <button id="btn-tts"       type="button" title="Ativar/Desativar leitura cont√≠nua">Voz: Off</button>
          <button id="btn-tts-prev"  type="button" title="Bloco anterior">‚óÄ</button>
          <button id="btn-tts-next"  type="button" title="Pr√≥ximo bloco">‚ñ∂</button>
          <button id="btn-tts-sel"   type="button" title="Ler apenas sele√ß√£o">Ler sele√ß√£o</button>
          <button id="btn-tts-stop"  type="button" title="Parar voz">Parar</button>
          <small data-tts-status>Pronto.</small>
        `;
      document.body.appendChild(wrap);
      btnT   = wrap.querySelector('#btn-tts');
      btnS   = wrap.querySelector('#btn-tts-sel');
      btnX   = wrap.querySelector('#btn-tts-stop');
      btnPrev= wrap.querySelector('#btn-tts-prev');
      btnNext= wrap.querySelector('#btn-tts-next');
      status = wrap.querySelector('[data-tts-status]');
    }else if(DOCKED){
      const w = btnT.closest('.kob-tts-panel'); if(w) w.classList.add('is-dock');
      btnT.textContent='üîä'; if(btnPrev) btnPrev.textContent='‚óÄ'; if(btnNext) btnNext.textContent='‚ñ∂';
      btnS.textContent='‚úÇÔ∏é'; btnX.textContent='‚ñ†';
    }

    return {wrap, btnT, btnS, btnX, btnPrev, btnNext, status};
  };

  // ‚Äî‚Äî‚Äî Toast seguro ‚Äî‚Äî‚Äî
  const toastSafe = (msg)=> { try{ if(typeof window.toast==='function') window.toast(msg); }catch(e){} };

  // ‚Äî‚Äî‚Äî Voz ‚Äî‚Äî‚Äî
  let voice = null;
  const pickVoice = ()=>{
    const vs = synth.getVoices() || [];
    return vs.find(v=>/pt[-_]BR/i.test(v.lang))
        || vs.find(v=>/pt/i.test(v.lang))
        || vs[0] || null;
  };
  const ensureVoice = ()=> { if(!voice) voice = pickVoice(); };
  synth.onvoiceschanged = ()=> { if(!voice) voice = pickVoice(); };

  // ‚Äî‚Äî‚Äî Estado TTS ‚Äî‚Äî‚Äî
  let blocks = [];        // [{ node, text }]
  let currentIndex = 0;
  let speaking = false;
  let utterance = null;
  let errorStreak = 0;
  const MAX_ERRORS = 3;

  // ‚Äî‚Äî‚Äî Utils ‚Äî‚Äî‚Äî
  const setLabel = (btn, on)=>{
    if(!btn) return;
    if(DOCKED){ btn.setAttribute('aria-pressed', on ? 'true' : 'false'); btn.textContent = 'üîä'; }
    else{ btn.textContent = 'Voz: ' + (on ? 'On' : 'Off'); }
  };
  const setStatus = (el, txt)=> { if(el) el.textContent = txt; };
  const clearHighlight = ()=> document.querySelectorAll('[data-tts-current]').forEach(el=>el.removeAttribute('data-tts-current'));
  const highlightCurrent = ()=>{
    clearHighlight();
    if(!blocks.length) return;
    const b = blocks[currentIndex]; if(!b || !b.node) return;
    b.node.setAttribute('data-tts-current','true');
    try{ b.node.scrollIntoView({behavior:'smooth', block:'center'});}catch(e){}
  };

  const BUILD_NODE_SEL = [
    'h1','h2','h3','h4','h5','h6',
    'p','li','blockquote','.callout',
    'pre.md-code','codeblock','table.md-table td','table.md-table th'
  ].join(',');

  const buildBlocksFromDOM = ()=>{
    const root = getRoot();
    const nodes = root.querySelectorAll(BUILD_NODE_SEL);
    const list = [];
    nodes.forEach(node=>{
      let text = (node.innerText || '').replace(/\bCopiar\b/g,'').trim();
      if(!text) return;
      list.push({ node, text });
    });
    blocks = list;
    currentIndex = 0;
    errorStreak = 0;
    setStatus(ui.status, blocks.length ? `TTS pronto: ${blocks.length} blocos.` : 'Nenhum bloco v√°lido.');
    if(blocks.length) toastSafe('TTS pronto: ' + blocks.length + ' blocos');
  };

  const stopInternal = ()=>{
    speaking = false; errorStreak = 0;
    try{ synth.cancel(); }catch(e){}
    if(utterance){ try{ utterance.onend=null; utterance.onerror=null; }catch(e){}; utterance=null; }
    clearHighlight(); setLabel(ui.btnT, false); setStatus(ui.status, 'TTS parado.');
  };

  const speakCurrent = ()=>{
    if(!blocks.length) buildBlocksFromDOM();
    if(!blocks.length){ stopInternal(); return; }

    if(currentIndex < 0) currentIndex = 0;
    if(currentIndex >= blocks.length){ stopInternal(); toastSafe('Fim dos blocos'); return; }

    const b = blocks[currentIndex];
    if(!b || !b.text || !b.text.trim()){
      errorStreak++;
      if(errorStreak > MAX_ERRORS){ toastSafe('Muitos blocos vazios/erro. Pausado.'); stopInternal(); return; }
      currentIndex++; speakCurrent(); return;
    }

    try{ synth.cancel(); }catch(e){}
    ensureVoice();

    utterance = new SpeechSynthesisUtterance(b.text.trim());
    if(voice) utterance.voice = voice;
    utterance.lang = (voice && voice.lang) || 'pt-BR';
    utterance.rate = 1.0; utterance.pitch = 1.0; utterance.volume = 1.0;

    utterance.onend   = ()=>{ if(!speaking) return; currentIndex++; speakCurrent(); };
    utterance.onerror = ()=>{ if(!speaking) return; errorStreak++; (errorStreak>MAX_ERRORS)?(toastSafe('Erros seguidos. Pausado.'), stopInternal()):(currentIndex++, speakCurrent()); };

    highlightCurrent();
    setStatus(ui.status, `Lendo ${currentIndex+1}/${blocks.length}‚Ä¶`);
    synth.speak(utterance);
  };

  // ‚Äî‚Äî‚Äî Controles ‚Äî‚Äî‚Äî
  const toggle = ()=>{
    if(speaking){ stopInternal(); toastSafe('Voz desativada'); return; }
    speaking = true; setLabel(ui.btnT, true);
    if(!blocks.length) buildBlocksFromDOM();
    speakCurrent(); toastSafe('Voz ativada');
  };
  const speakSelection = ()=>{
    const text = (window.getSelection && String(window.getSelection())) || '';
    const t = text.trim();
    if(!t){ toastSafe('Selecione um trecho primeiro'); return; }
    ensureVoice(); try{ synth.cancel(); }catch(e){}
    const u = new SpeechSynthesisUtterance(t);
    if(voice) u.voice = voice;
    u.lang = (voice && voice.lang) || 'pt-BR';
    u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
    synth.speak(u);
  };
  const nextBlock = ()=>{ if(!blocks.length) buildBlocksFromDOM(); speaking = true; setLabel(ui.btnT, true); currentIndex++; speakCurrent(); };
  const prevBlock = ()=>{ if(!blocks.length) buildBlocksFromDOM(); speaking = true; setLabel(ui.btnT, true); currentIndex = Math.max(0, currentIndex-1); speakCurrent(); };

  // ‚Äî‚Äî‚Äî Auto-wire: bot√µes externos "TTS" / "ouvir TTS" ‚Äî‚Äî‚Äî
  const isTTSLabel = (el)=>{
    const t = (el.textContent||'').toLowerCase().replace(/\s+/g,' ').trim();
    return /\btts\b/.test(t) || t.includes('ouvir tts');
  };
  const bindExternal = (root=document)=>{
    const candidates = Array.from(root.querySelectorAll('button, a, [role="button"], .btn, .button'))
      .filter(el=>!el.dataset.kobTtsBound && isTTSLabel(el));
    candidates.forEach(el=>{
      el.dataset.kobTtsBound = '1';
      el.addEventListener('click', (e)=>{ e.preventDefault(); toggle(); }, { passive:false });
      el.title = (el.title||'') || 'Ativar/Desativar TTS';
    });
  };
  const mo = new MutationObserver((muts)=>{
    for(const m of muts){
      if(m.addedNodes) m.addedNodes.forEach(n=>{ if(n.nodeType===1) bindExternal(n); });
    }
  });

  // ‚Äî‚Äî‚Äî Drag + persist√™ncia ‚Äî‚Äî‚Äî
  const applySavedDockPos = ()=>{
    try{
      const saved = JSON.parse(localStorage.getItem(POS_KEY)||'null');
      if(saved && typeof saved.left==='number' && typeof saved.bottom==='number'){
        document.documentElement.style.setProperty('--tts-dock-left', `${saved.left}px`);
        document.documentElement.style.setProperty('--tts-dock-bottom', `${saved.bottom}px`);
      }
    }catch(e){}
  };
  const enableDrag = (wrap)=>{
    if(!DRAG_ENABLED || !wrap) return;
    let startX=0, startY=0, startLeft=0, startBottom=0, dragging=false;

    const onDown = (ev)=>{
      const e = ev.touches ? ev.touches[0] : ev;
      dragging=true; wrap.classList.add('is-dragging');
      startX = e.clientX; startY = e.clientY;
      const cs = getComputedStyle(document.documentElement);
      startLeft   = parseFloat(cs.getPropertyValue('--tts-dock-left')) || 8;
      startBottom = parseFloat(cs.getPropertyValue('--tts-dock-bottom')) || 269;
      window.addEventListener('pointermove', onMove, {passive:false});
      window.addEventListener('pointerup', onUp, {passive:false});
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('touchend', onUp, {passive:false});
    };
    const onMove = (ev)=>{
      if(!dragging) return;
      const e = ev.touches ? ev.touches[0] : ev;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const left = Math.max(0, startLeft + dx);
      const bottom = Math.max(0, startBottom - dy); // mover para cima aumenta bottom
      document.documentElement.style.setProperty('--tts-dock-left', `${left}px`);
      document.documentElement.style.setProperty('--tts-dock-bottom', `${bottom}px`);
    };
    const onUp = ()=>{
      if(!dragging) return;
      dragging=false; wrap.classList.remove('is-dragging');
      const cs = getComputedStyle(document.documentElement);
      const left   = parseFloat(cs.getPropertyValue('--tts-dock-left')) || 8;
      const bottom = parseFloat(cs.getPropertyValue('--tts-dock-bottom')) || 269;
      try{ localStorage.setItem(POS_KEY, JSON.stringify({left,bottom})); }catch(e){}
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
      window.removeEventListener('touchmove', onMove);
      window.removeEventListener('touchend', onUp);
    };

    wrap.addEventListener('pointerdown', onDown);
    wrap.addEventListener('touchstart', onDown);
  };

  // ‚Äî‚Äî‚Äî Boot ‚Äî‚Äî‚Äî
  let ui = {wrap:null,btnT:null,btnS:null,btnX:null,status:null,btnPrev:null,btnNext:null};

  const boot = ()=>{
    applySavedDockPos();
    const got = ensurePanel();
    ui = {
      wrap:   got.wrap,
      btnT:   got.btnT,
      btnS:   got.btnS,
      btnX:   got.btnX,
      status: got.status,
      btnPrev: got.btnPrev,
      btnNext: got.btnNext,
    };
    setLabel(ui.btnT,false);
    setStatus(ui.status,'Pronto.');

    // binds painel
    ui.btnT   && ui.btnT.addEventListener('click', e=>{e.preventDefault(); toggle();});
    ui.btnS   && ui.btnS.addEventListener('click', e=>{e.preventDefault(); speakSelection();});
    ui.btnX   && ui.btnX.addEventListener('click', e=>{e.preventDefault(); stopInternal();});
    ui.btnPrev&& ui.btnPrev.addEventListener('click', e=>{e.preventDefault(); prevBlock();});
    ui.btnNext&& ui.btnNext.addEventListener('click', e=>{e.preventDefault(); nextBlock();});

    // teclado opcional (‚Üê/‚Üí)
    window.addEventListener('keydown', (ev)=>{
      if(ev.target && /input|textarea/i.test(ev.target.tagName)) return;
      if(ev.key==='ArrowRight'){ nextBlock(); }
      if(ev.key==='ArrowLeft'){ prevBlock(); }
    });

    // integra com ACTIONS (compat)
    window.ACTIONS = window.ACTIONS || {};
    const oldTTS = window.ACTIONS.tts;
    window.ACTIONS.tts = ()=>{ try{ toggle(); }catch(e){}; if(typeof oldTTS==='function'){ /* compat */ } };
    window.ACTIONS.ttsPrev = ()=>{ prevBlock(); };
    window.ACTIONS.ttsNext = ()=>{ nextBlock(); };
    window.ACTIONS.ttsStop = ()=>{ stopInternal(); };

    // exp√µe API global
    window.KOBLLUX_TTS = {
      rebuild: ()=>buildBlocksFromDOM(),
      play: ()=>{ if(!speaking){ speaking=true; setLabel(ui.btnT,true); } speakCurrent(); },
      stop: stopInternal,
      next: nextBlock,
      prev: prevBlock,
      info: ()=>({ blocks:blocks.length, currentIndex, speaking })
    };

    // Auto-wire em bot√µes externos
    bindExternal(document);
    mo.observe(document.documentElement, {childList:true, subtree:true});

    // Drag opcional
    if(DOCKED && DRAG_ENABLED){ enableDrag(ui.wrap); }
  };

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  }else{
    boot();
  }
})();
</script>
<!-- /KOBLLUX :: PATCH √öNICO ‚Äî TTS por Blocos -->

<!-- KOBLLUX :: TTS v32 ‚Äî Dock + Outline + Vozes PT-BR + ASCII + Status compacto -->
<script>
(()=>{ if(window.__KOB_TTS_V32_ACTIVE) return; window.__KOB_TTS_V32_ACTIVE = true;

  /* ---------- Constantes & Prefer√™ncias ---------- */
  const POS_KEY  = 'kob_tts_pos_v3';
  const PREF_KEY = 'kob_tts_prefs_v32';
  const ROOTS    = ['#root','[data-analyzer-output]','.analyzer-output','#render','main','.content'];
  const BLOCK_SEL= [
    'h1','h2','h3','h4','h5','h6',
    'p','li','blockquote','.callout','.equation','pre','td','th','codeblock'
  ].join(',');

  const PREFS = Object.assign({
    outline: true,
    asciiMode: 'describe',      // 'describe' | 'skip' | 'read'
    clickToSpeak: true,         // clicar no bloco inicia leitura
    preferMale: true            // prioridade de vozes
  }, readPrefs());

  /* ---------- Util ---------- */
  const $  = (q, r=document)=> r.querySelector(q);
  const $$ = (q, r=document)=> [...r.querySelectorAll(q)];
  const setCSS = (v,val)=> document.documentElement.style.setProperty(v,val);
  const toast  = (m)=> { try{ window.toast && window.toast(m); }catch{} };
  const getRoot= ()=> { for(const s of ROOTS){ const el=document.querySelector(s); if(el) return el; } return document.body; };

  /* ---------- Dock ---------- */
  const dock = document.querySelector('.kob-tts-dock') || (()=> {
    const d = document.createElement('div');
    d.className = 'kob-tts-dock';
    d.innerHTML = `
      <button id="tts-on"      title="Voz On/Off" aria-pressed="false">üîä</button>
      <button id="tts-prev"    title="Anterior">‚óÄ</button>
      <button id="tts-next"    title="Pr√≥ximo">‚ñ∂</button>
      <button id="tts-sel"     title="Ler sele√ß√£o">‚úÇÔ∏é</button>
      <button id="tts-stop"    title="Parar">‚ñ†</button>
      <button id="tts-reread"  title="Re-Ler do in√≠cio (abrir tudo)">‚ü≥</button>
      <button id="tts-reset"   title="Reset + pr√≥xima se√ß√£o">‚Üª</button>
      <button id="tts-openall" title="Abrir Tudo (acordeons/detalhes)">‚óé</button>
      <button id="tts-grid"    title="Outline / Click-to-Speak">‚åó</button>
      <button id="tts-voice"   title="Trocar Voz PT-BR (segurar: alterna masc/fem)">üéô</button>
      <small id="tts-status">Pronto.</small>
    `;
    document.body.appendChild(d);
    return d;
  })();

  /* Outline/grade */
  const outline = document.getElementById('kob-tts-outline') || (()=> {
    const o = document.createElement('div');
    o.id='kob-tts-outline';
    document.body.appendChild(o);
    return o;
  })();

  /* Drag e posi√ß√£o */
  applySavedPos();
  ;(()=>{ let sx=0,sy=0,sl=0,sb=0,drag=false;
    const onDown=(ev)=>{ const e=ev.touches?ev.touches[0]:ev; drag=true; dock.classList.add('is-drag'); sx=e.clientX; sy=e.clientY;
      const cs=getComputedStyle(document.documentElement);
      sl=parseFloat(cs.getPropertyValue('--tts-left'))||8;
      sb=parseFloat(cs.getPropertyValue('--tts-bottom'))||240;
      addEventListener('pointermove',onMove,{passive:false});
      addEventListener('pointerup',onUp,{passive:false});
      addEventListener('touchmove',onMove,{passive:false});
      addEventListener('touchend',onUp,{passive:false});
    };
    const onMove=(ev)=>{ if(!drag) return; const e=ev.touches?ev.touches[0]:ev;
      const dx=e.clientX-sx, dy=e.clientY-sy;
      setCSS('--tts-left',   Math.max(0, sl+dx)+'px');
      setCSS('--tts-bottom', Math.max(0, sb-dy)+'px');
    };
    const onUp=()=>{ if(!drag) return; drag=false; dock.classList.remove('is-drag'); savePos(); };
    dock.addEventListener('pointerdown',onDown); dock.addEventListener('touchstart',onDown);
  })();

  /* ---------- Speech & Vozes ---------- */
  const synth = ('speechSynthesis' in window) ? window.speechSynthesis : null;
  if(!synth){ console.warn('[TTS] SpeechSynthesis indispon√≠vel'); return; }
  try{ synth.cancel(); }catch{}

  let VOICES=[], baseVoice=null, voiceIdx=0;
  const MALE   = /(ricardo|thiago|jo[a√£]o|daniel|felipe|bruno|rafael|marc(o|os)|c[a√°]ssio)/i;
  const FEMALE = /(luciana|camila|fabiana|maria|helena|ana|carla|bia|let[i√≠]cia|fernanda)/i;

  function loadVoices(){
    VOICES = synth.getVoices()||[];
    const pt = VOICES.filter(v=>/pt/i.test(v.lang));
    const pri = (PREFS.preferMale? MALE : FEMALE);
    const sec = (PREFS.preferMale? FEMALE: MALE);
    baseVoice = pt.find(v=> pri.test(v.name||'')) || pt.find(v=> sec.test(v.name||'')) || pt[0] || VOICES[0] || null;
    voiceIdx  = Math.max(0, (pt.indexOf(baseVoice)));
  }
  synth.onvoiceschanged = ()=> loadVoices();
  loadVoices();

  function cycleVoice(){
    const pt = VOICES.filter(v=>/pt/i.test(v.lang));
    if(!pt.length) return;
    voiceIdx = (voiceIdx+1) % pt.length;
    baseVoice = pt[voiceIdx];
    setStatus(`Voz: ${baseVoice.name||baseVoice.lang}`);
  }
  function toggleVoicePriority(){ // segurar
    PREFS.preferMale = !PREFS.preferMale; savePrefs();
    loadVoices();
    setStatus(`Prefer√™ncia: ${PREFS.preferMale?'masculina':'feminina'}`);
  }

  const ARCH_STYLES = {
    atlas:{ rate:.95, pitch:1.00, find:/\b(atlas)\b/i },
    nova:{ rate:1.12, pitch:1.12, find:/\b(nova)\b/i },
    vitalis:{ rate:1.08, pitch:1.05, find:/\b(vitalis)\b/i },
    pulse:{ rate:1.04, pitch:1.08, find:/\b(pulse|pulso)\b/i },
    serena:{ rate:.98, pitch:.96, find:/\b(serena)\b/i },
    kaos:{ rate:1.18, pitch:1.02, find:/\b(kaos)\b/i },
    genus:{ rate:1.00, pitch:1.00, find:/\b(genus)\b/i },
    lumine:{ rate:1.0, pitch:1.10, find:/\b(lumine)\b/i },
    rhea:{ rate:.97, pitch:1.00, find:/\b(rhea)\b/i },
    solus:{ rate:.93, pitch:.95, find:/\b(solus)\b/i },
    aion:{ rate:1.00, pitch:1.08, find:/\b(aion)\b/i }
  };
  function voiceStyleFor(text){
    for(const k in ARCH_STYLES){ if(ARCH_STYLES[k].find.test(text)) return ARCH_STYLES[k]; }
    return {rate:1.01,pitch:1.0};
  }
  function pickVoiceFor(text){
    const st = voiceStyleFor(text);
    return { voice: baseVoice, rate: st.rate, pitch: st.pitch };
  }

  /* ---------- Estado ---------- */
  let blocks=[], idx=0, speaking=false, u=null;

  function setPressed(btn,on){ btn?.setAttribute('aria-pressed', on?'true':'false'); }
  function setStatus(t){ const el=$('#tts-status',dock); if(!el) return; el.textContent=String(t); }
  function setStatusProgress(){ const el=$('#tts-status',dock); if(!el) return;
    if(!blocks.length){ el.textContent='0/0'; return; }
    el.textContent = `${Math.min(idx+1,blocks.length)}/${blocks.length}`;
  }

  function isAsciiArt(txt){
    const lines=txt.split(/\n/);
    const raw=txt.replace(/\s+/g,'');
    const nonWord=(raw.replace(/[A-Za-z√Ä-√ø0-9]/g,'').length)/(raw.length||1);
    const box=/[‚ñë‚ñí‚ñì‚ñà‚ñÄ‚ñÑ‚ñå‚ñê‚îÄ‚ïê‚ïë‚ïî‚ïó‚ïù‚ïö‚ï©‚ï¶‚ï†‚ï£‚îå‚îê‚îî‚îò]/.test(txt);
    const wide=lines.some(l=> l.length>28 && l.replace(/[A-Za-z√Ä-√ø0-9]/g,'').length/(l.length||1)>.45);
    return box || nonWord>.42 || wide;
  }
  function describeAscii(txt){
    const t=txt||''; const parts=[];
    if(/[‚ñà‚ñì‚ñí‚ñë]{4,}/.test(t)) parts.push('massa s√≥lida');
    if(/[‚îÄ‚ïê]{4,}/.test(t))   parts.push('linhas horizontais');
    if(/[‚îº‚ï¨‚ï¶‚ï©‚ï†‚ï£]/.test(t))   parts.push('grade geom√©trica');
    if(/[‚ñ≥‚ñ≤‚ñµ]/.test(t))     parts.push('tri√¢ngulos');
    if(/[‚óã‚óè‚óØ]/.test(t))     parts.push('c√≠rculos');
    return 'Arte ASCII' + (parts.length?(' ‚Äî '+parts.join(', ')):'');
  }
  function stripKaTeX(s){
    // remove $$‚Ä¶$$ e $‚Ä¶$ do KaTeX/LaTeX para n√£o ‚Äúsoletrar‚Äù s√≠mbolos
    s = s.replace(/\$\$[\s\S]*?\$\$/g,' ');
    s = s.replace(/\$[^$]*\$/g,' ');
    return s;
  }
  function sanitize(txt,type){
    let s = stripKaTeX(txt||'');
s = s.replace(/[\\/*_|=`~^<>#${}()+\-]+/g, ' ');
s = s.replace(/\$begin:math:display\$\$[\s\S]*?\$\$end:math:display\$/g, ' ');
    s = s.replace(/:+/g, ', ').replace(/\.+/g, ', ');
    s = s.replace(/\s{2,}/g,' ').trim();
    if(type==='code')     return 'Bloco de c√≥digo com ' + (txt.split(/\n/).length) + ' linhas.';
    if(type==='equation') return 'Equa√ß√£o matem√°tica.';
    if(type==='ascii'){
      if(PREFS.asciiMode==='skip') return '';
      if(PREFS.asciiMode==='describe') return describeAscii(txt);
    }
    return s;
  }

  function sectionIndexOf(node){
    const secs = $$('#root details, details, .acc details, details.acc');
    const i = secs.findIndex(d=> d.contains(node));
    return i<0?0:i;
  }

  /* ---------- EXPANDIR TODOS ---------- */
  function expandAll(open=true){
    $$('details').forEach(d=> d.open = !!open);
    $$('[aria-expanded]').forEach(el=>{
      el.setAttribute('aria-expanded', open?'true':'false');
      const id = el.getAttribute('aria-controls');
      if(id){ const tgt = document.getElementById(id); if(tgt) tgt.hidden = !open; }
    });
    $$('[data-open]').forEach(el=> el.setAttribute('data-open', open?'1':'0'));
  }

  /* ---------- Build ---------- */
  function rebuild(){
    const root = getRoot();
    const nodes = $$(BLOCK_SEL, root);
    const out=[];
    for(const node of nodes){
      let raw = (node.innerText||'').replace(/\bCopiar\b/g,'').trim();
      if(!raw) continue;
      const type = node.matches('pre') ? 'code'
                : node.matches('.equation') ? 'equation'
                : isAsciiArt(raw) ? 'ascii'
                : node.matches('blockquote,.callout') ? 'quote'
                : node.matches('li') ? 'list'
                : node.matches('td,th') ? 'cell'
                : node.matches('h1,h2,h3,h4,h5,h6') ? 'heading'
                : 'para';
      out.push({ node, raw, type, sectionIdx: sectionIndexOf(node) });
    }
    blocks = out; idx = 0;
    setStatus(blocks.length ? `${blocks.length}/${blocks.length}` : '0/0');
  }

  /* ---------- Outline ---------- */
  function hideOutline(){ outline.style.display='none'; }
  function showOutlineFor(node){
    if(!PREFS.outline || !node) return hideOutline();
    const r=node.getBoundingClientRect();
    outline.style.display='block';
    outline.style.left  =(scrollX+r.left-6)+'px';
    outline.style.top   =(scrollY+r.top -6)+'px';
    outline.style.width =(r.width+12)+'px';
    outline.style.height=(r.height+12)+'px';
  }
  function highlight(){
    $$('[data-tts-current]').forEach(el=>el.removeAttribute('data-tts-current'));
    const b=blocks[idx]; if(!b) return;
    b.node.setAttribute('data-tts-current','true');
    try{ b.node.scrollIntoView({behavior:'smooth', block:'center'});}catch{}
    showOutlineFor(b.node);
  }
  addEventListener('scroll', ()=>{ const b=blocks[idx]; if(PREFS.outline && b) showOutlineFor(b.node); }, {passive:true});
  addEventListener('resize', ()=>{ const b=blocks[idx]; if(PREFS.outline && b) showOutlineFor(b.node); });

  /* ---------- Speak ---------- */
  function speakCurrent(){
    if(!blocks.length) rebuild();
    if(idx<0) idx=0;
    if(idx>=blocks.length){ stop(); toast('Fim.'); return; }

    const b = blocks[idx];
    const text = sanitize(b.raw, b.type);
    if(!text){ idx++; setStatusProgress(); return speakCurrent(); }

    try{ synth.cancel(); }catch{}
    const conf = pickVoiceFor(text);
    const u = new SpeechSynthesisUtterance(text);
    if(conf.voice) u.voice = conf.voice;
    u.lang = (conf.voice && conf.voice.lang) || 'pt-BR';
    u.rate = conf.rate; u.pitch = conf.pitch; u.volume=1;

    u.onend   = ()=>{ if(!speaking) return; idx++; setStatusProgress(); speakCurrent(); };
    u.onerror = ()=>{ if(!speaking) return; idx++; setStatusProgress(); speakCurrent(); };

    highlight();
    setStatusProgress();
    synth.speak(u);
  }
  function play(){ speaking=true; setPressed($('#tts-on',dock),true); if(!blocks.length) rebuild(); speakCurrent(); }
  function stop(){ speaking=false; try{ synth.cancel(); }catch{} setPressed($('#tts-on',dock),false); setStatus(blocks.length?`${Math.min(idx+1,blocks.length)}/${blocks.length}`:'Pausado.'); hideOutline(); }
  function toggle(){ speaking ? stop() : play(); }
  function next(){ if(!blocks.length) rebuild(); speaking=true; setPressed($('#tts-on',dock),true); idx++; setStatusProgress(); speakCurrent(); }
  function prev(){ if(!blocks.length) rebuild(); speaking=true; setPressed($('#tts-on',dock),true); idx=Math.max(0,idx-1); setStatusProgress(); speakCurrent(); }

  /* ---------- Reset & Re-Ler ---------- */
  function reset(opts={}){
    expandAll(true);
    stop(); rebuild();
    if(opts.nextSection===true){
      const cur = blocks[idx]?.sectionIdx ?? 0;
      const j = blocks.findIndex(b=> b.sectionIdx>cur);
      idx = j>=0 ? j : 0;
    }else if(typeof opts.sectionIndex==='number'){
      const j = blocks.findIndex(b=> b.sectionIdx===opts.sectionIndex);
      idx = j>=0 ? j : 0;
    }else{
      idx = 0;
    }
    setStatus(blocks.length?`${idx+1}/${blocks.length}`:'Pronto.');
    if(PREFS.outline && blocks[idx]) showOutlineFor(blocks[idx].node);
  }
  function rereadFromStart(){
    expandAll(true);
    rebuild();
    idx=0; play();
  }

  /* ---------- Click-to-Speak (Outline ON) ---------- */
  document.addEventListener('click', (ev)=>{
    const blk = ev.target.closest(BLOCK_SEL);
    if(!blk) return;
    const i = blocks.findIndex(b=> b.node===blk);
    if(i<0) return;
    idx=i;
    if(PREFS.outline) showOutlineFor(blk);
    if(PREFS.clickToSpeak){
      speaking=true; setPressed($('#tts-on',dock),true);
      speakCurrent();
    }else{
      setStatusProgress();
    }
  }, {passive:false});

  /* ---------- Sele√ß√£o ---------- */
  $('#tts-sel',dock)?.addEventListener('click', (e)=>{
    e.preventDefault();
    const t = String(window.getSelection && window.getSelection()).trim();
    if(!t){ toast('Selecione um trecho'); return; }
    try{ synth.cancel(); }catch{}
    const conf = pickVoiceFor(t);
    const uu = new SpeechSynthesisUtterance(sanitize(t,'para'));
    if(conf.voice) uu.voice=conf.voice;
    uu.lang=(conf.voice&&conf.voice.lang)||'pt-BR'; uu.rate=conf.rate; uu.pitch=conf.pitch; uu.volume=1;
    synth.speak(uu);
  });

  /* ---------- Bot√µes ---------- */
  $('#tts-on',dock)?.addEventListener('click', e=>{ e.preventDefault(); toggle(); });
  $('#tts-prev',dock)?.addEventListener('click', e=>{ e.preventDefault(); prev(); });
  $('#tts-next',dock)?.addEventListener('click', e=>{ e.preventDefault(); next(); });
  $('#tts-stop',dock)?.addEventListener('click', e=>{ e.preventDefault(); stop(); });
  $('#tts-reset',dock)?.addEventListener('click', e=>{ e.preventDefault(); reset({nextSection:true}); });
  $('#tts-reread',dock)?.addEventListener('click', e=>{ e.preventDefault(); rereadFromStart(); });
  $('#tts-openall',dock)?.addEventListener('click', e=>{ e.preventDefault(); expandAll(true); rebuild(); setStatusProgress(); });

  // Outline toggle (e click-to-speak junto)
  $('#tts-grid',dock)?.addEventListener('click', e=>{
    e.preventDefault();
    PREFS.outline = !PREFS.outline;
    PREFS.clickToSpeak = PREFS.outline;
    savePrefs();
    if(!PREFS.outline) hideOutline(); else { const b=blocks[idx]; b && showOutlineFor(b.node); }
    setPressed($('#tts-grid',dock), PREFS.outline);
  });
  setPressed($('#tts-grid',dock), PREFS.outline);

  // Voz: click = cicla, longpress = alterna prioridade masc/fem
  ;(()=>{ const btn=$('#tts-voice',dock); if(!btn) return;
    let pressT=null, pressed=false;
    const down=()=>{ pressed=true; pressT=setTimeout(()=>{ pressed='hold'; toggleVoicePriority(); }, 550); };
    const up=()=>{ if(pressT){ clearTimeout(pressT); pressT=null; } if(pressed===true){ cycleVoice(); } pressed=false; };
    btn.addEventListener('pointerdown', down); btn.addEventListener('pointerup', up); btn.addEventListener('pointerleave', up);
    btn.addEventListener('touchstart', down);  btn.addEventListener('touchend', up);
  })();

  /* ---------- Integrar com AUTO-GERAR do app ---------- */
  hook('autoBuild'); hook('autoBuildNested');
  function hook(name){
    if(typeof window[name]==='function'){
      const orig=window[name];
      window[name]=function(){
        const out=orig.apply(this, arguments);
        setTimeout(()=>{ expandAll(true); rebuild(); setStatusProgress(); }, 30);
        return out;
      }
    }
  }

  /* ---------- Boot ---------- */
  try{ window.__tts && typeof window.__tts.stop==='function' && window.__tts.stop(); }catch{}
  expandAll(true);
  rebuild();
  setStatusProgress();

  /* ---------- Helpers ---------- */
  function readPrefs(){ try{ return JSON.parse(localStorage.getItem(PREF_KEY)||'{}'); }catch{ return {}; } }
  function savePrefs(){ try{ localStorage.setItem(PREF_KEY, JSON.stringify(PREFS)); }catch{} }
  function applySavedPos(){
    try{
      const s=JSON.parse(localStorage.getItem(POS_KEY)||'null');
      if(s){ setCSS('--tts-left', s.left); setCSS('--tts-bottom', s.bottom); }
    }catch{}
  }
  function savePos(){
    try{
      const cs=getComputedStyle(document.documentElement);
      localStorage.setItem(POS_KEY, JSON.stringify({
        left: cs.getPropertyValue('--tts-left').trim(),
        bottom: cs.getPropertyValue('--tts-bottom').trim()
      }));
    }catch{}
  }
})();
</script>

<script>
/* PATCH: substitui a fun√ß√£o pickVoiceFor original pela vers√£o com HOOK */
function pickVoiceFor(text){
  // se existir um hook externo (IA), tenta classificar primeiro
  try{
    if (window.KOB_TTS_VOICE_STYLE_HOOK) {
      const arch = window.KOB_TTS_VOICE_STYLE_HOOK(text);
      if (arch) {
        const ST = {
          atlas:{rate:.95,pitch:0.80}, nova:{rate:1.09,pitch:1.18},
          vitalis:{rate:1.08,pitch:1.34}, pulse:{rate:1.02,pitch:1.12},
          serena:{rate:.98,pitch:.96}, kaos:{rate:1.13,pitch:1.02},
          genus:{rate:1.00,pitch:1.00}, lumine:{rate:1.00,pitch:1.28},
          rhea:{rate:.97,pitch:0.78}, solus:{rate:.93,pitch:.95},
          aion:{rate:1.00,pitch:1.08}
        }[String(arch).toLowerCase()];
        if (ST) return { voice: baseVoice, rate: ST.rate, pitch: ST.pitch };
      }
    }
  }catch(e){}
  // fallback regex (v32)
  const st = voiceStyleFor(text);
  return { voice: baseVoice, rate: st.rate, pitch: st.pitch };
}
</script>

<!-- KOBLLUX :: TTS v32.2 ‚Äî Patch Correto (clique + dock + limpeza de texto) -->
<script id="KOB_TTS_V32_2">
(()=>{

  if(window.__KOB_TTS_V32_2_ACTIVE) return;
  window.__KOB_TTS_V32_2_ACTIVE = true;

  if(!('speechSynthesis' in window)){
    console.warn('SpeechSynthesis n√£o suportado neste navegador.');
    return;
  }

  /* ========= ESTADO GLOBAL ========= */
  window.__tts_on = false;
  let __tts_voice = null;
  let __tts_utterance = null;

  function $(sel, root=document){ return root.querySelector(sel); }

  function getStatusEl(){
    return document.getElementById('tts-status');
  }

  function setStatus(msg){
    const el = getStatusEl();
    if(el) el.textContent = msg || '';
  }

  /* ========= VOZ ========= */
  function pickPTBRVoice(){
    const voices = speechSynthesis.getVoices();
    const cand =
      voices.find(v => /pt[-_]BR/i.test(v.lang)) ||
      voices.find(v => /pt\b/i.test(v.lang));
    return cand || voices[0] || null;
  }

  function ensureVoice(){
    if(!__tts_voice){
      __tts_voice = pickPTBRVoice();
    }
  }

  /* ========= LIMPEZA DO TEXTO ========= */
  function cleanText(raw){
    if(!raw) return '';
    let text = String(raw);

    // Remove r√≥tulos e lixinhos √≥bvios
    text = text.replace(/Copiar/g, ' ');

    // Quebras de linha, \n, etc ‚Üí espa√ßo
    text = text.replace(/\\n|[\r\n]+/g, ' ');

    // Remove barras invertidas sobrando
    text = text.replace(/\\+/g, '');

    // Normaliza barras normais (evita "barra barra barra")
    text = text.replace(/[\/]{2,}/g, '/');

    // Espa√ßos m√∫ltiplos ‚Üí um espa√ßo
    text = text.replace(/\s{2,}/g, ' ');

    // Trim final
    text = text.trim();

    // Se for muito curtinho ou s√≥ s√≠mbolo, n√£o fala
    if(text.length <= 3) return '';

    return text;
  }

  /* ========= FALAR / PARAR ========= */
  function speakText(text){
    const cleaned = cleanText(text);
    if(!cleaned) return;

    if(!window.__tts_on){
      window.toast && toast('Ative a Voz (TTS)');
      return;
    }

    ensureVoice();
    speechSynthesis.cancel();
    setStatus('Lendo...');

    const u = new SpeechSynthesisUtterance(cleaned);
    __tts_utterance = u;

    if(__tts_voice) u.voice = __tts_voice;
    u.lang = (__tts_voice && __tts_voice.lang) || 'pt-BR';
    u.rate = 1.12;
    u.pitch = 0.78;
    u.volume = 1.0;

    u.onstart = () => setStatus('Lendo...');
    u.onend   = () => setStatus('Pronto');
    u.onerror = () => setStatus('Erro na voz');

    speechSynthesis.speak(u);
  }

  function stopTTS(){
    speechSynthesis.cancel();
    __tts_utterance = null;
    setStatus('Parado');
  }

  function getSelectedText(){
    return (window.getSelection && String(window.getSelection())) || '';
  }

  function setTTS(on){
    window.__tts_on = !!on;
    const btnFab = document.getElementById('btn-tts');
    if(btnFab){
      btnFab.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
    }
    const dockBtn = document.querySelector('[data-tts-btn="toggle"]');
    if(dockBtn){
      dockBtn.setAttribute('aria-pressed', window.__tts_on ? 'true' : 'false');
    }
    setStatus(window.__tts_on ? 'TTS ligado' : 'TTS desligado');
    window.toast && toast(window.__tts_on ? 'Voz ativada' : 'Voz desativada');
  }

  /* ========= DOCK LATERAL (se ainda n√£o existir) ========= */
  function ensureTTSDock(){
    if(document.querySelector('.kob-tts-dock')) return;

    const dock = document.createElement('div');
    dock.className = 'kob-tts-dock';
    dock.innerHTML = `
      <button type="button" data-tts-btn="toggle" title="TTS On/Off" aria-pressed="false">‚óé</button>
      <button type="button" data-tts-btn="sel"    title="Ler sele√ß√£o">‚ñ∑</button>
      <button type="button" data-tts-btn="stop"   title="Parar voz">‚ñ†</button>
      <span id="tts-status"></span>
    `;
    document.body.appendChild(dock);

    // status inicial
    setStatus('TTS desligado');

    // drag simples
    let dragging = false;
    let startX = 0, startY = 0;
    let startLeft = 0, startBottom = 0;

    dock.addEventListener('pointerdown', (ev)=>{
      if(!(ev.target instanceof HTMLElement)) return;
      // s√≥ arrasta se clicar na √°rea vazia do dock (n√£o nos bot√µes)
      if(ev.target.closest('button')) return;

      dragging = true;
      dock.classList.add('is-drag');
      startX = ev.clientX;
      startY = ev.clientY;
      const cs = getComputedStyle(dock);
      startLeft = parseFloat(cs.left || '8');
      startBottom = parseFloat(cs.bottom || '240');
      dock.setPointerCapture(ev.pointerId);
    });

    dock.addEventListener('pointermove', (ev)=>{
      if(!dragging) return;
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      const left = startLeft + dx;
      const bottom = startBottom - dy;
      dock.style.left = `${left}px`;
      dock.style.bottom = `${bottom}px`;
    });

    dock.addEventListener('pointerup', (ev)=>{
      if(!dragging) return;
      dragging = false;
      dock.classList.remove('is-drag');
      dock.releasePointerCapture(ev.pointerId);
    });
  }

  /* ========= LISTENERS GERAIS ========= */

  // Integra com bot√µes existentes (FAB, MasterBlock, Dock)
  document.addEventListener('click',(e)=>{
    const t = e.target;
    if(!(t instanceof HTMLElement)) return;

    // 1) Bot√µes dedicados (IDs existentes + dock)
    const isFabToggle = t.id === 'btn-tts';
    const isFabSel    = t.id === 'btn-tts-sel';
    const isFabStop   = t.id === 'btn-tts-stop';

    const dockRole = t.dataset.ttsBtn;

    if(isFabToggle || dockRole === 'toggle'){
      setTTS(!window.__tts_on);
      return;
    }
    if(isFabSel || dockRole === 'sel'){
      const sel = getSelectedText();
      if(sel) speakText(sel);
      else window.toast && toast('Selecione um trecho primeiro');
      return;
    }
    if(isFabStop || dockRole === 'stop'){
      stopTTS();
      return;
    }

    // 2) Se TTS desligado, n√£o faz nada no resto
    if(!window.__tts_on) return;

    // 3) Clique em bloco de texto ‚Üí ler
    const block = t.closest('p, li, blockquote, .coach, .callout, .equation, pre, td, th');
    if(!block) return;

    // Ignora cliques em zonas de UI
    if(t.closest('button,a,.emoji-btn,.chip,.btn,#fab,.menu,#ttsDock,.kob-tts-dock')) return;

    // N√ÉO ler c√≥digo nem f√≥rmulas (sen√£o soletra tudo)
    if(block.matches('pre, .equation')) return;

    let text = block.innerText || '';
    speakText(text);
  });

  // Voicelist
  if('speechSynthesis' in window){
    speechSynthesis.onvoiceschanged = ()=>{
      if(!__tts_voice) __tts_voice = pickPTBRVoice();
    };
  }

  // Quando DOM carregar: garantir Dock
  window.addEventListener('DOMContentLoaded', ()=>{
    try{
      ensureTTSDock();
      // Ajusta label inicial do bot√£o principal (se existir)
      const b = document.getElementById('btn-tts');
      if(b){
        b.textContent = 'Voz: ' + (window.__tts_on ? 'On' : 'Off');
      }
      setStatus('TTS desligado');
    }catch(err){
      console.error('Erro ao inicializar TTS dock', err);
    }
  });

  // Expor API global opcional
  window.__tts = {
    set: setTTS,
    speak: speakText,
    stop: stopTTS,
    status: setStatus
  };

})();
</script>


<!-- BIG_LOCK_RESET_v1 ‚Äî limpa locks e for√ßa prefer√™ncias de base -->
<script id="BIG_LOCK_RESET_v1">
(()=>{
  try{
    const K='kob_tts_prefs_v32';
    const p = Object.assign({preferMale:false,userLockedBase:false,voiceName:''}, JSON.parse(localStorage.getItem(K)||'{}'));
    p.preferMale=false; p.userLockedBase=false; p.voiceName='';
    localStorage.setItem(K, JSON.stringify(p));
  }catch{}
  // opcional: exp√µe um atalho pro console
  window.__kob_reset_tts_prefs = ()=>{
    try{
      const K='kob_tts_prefs_v32';
      const p = {preferMale:false,userLockedBase:false,voiceName:''};
      localStorage.setItem(K, JSON.stringify(p));
      return p;
    }catch(e){ return e&&e.message; }
  };
})();
</script>




<!-- KOBLLUX ¬∑ Vozes Arqu√©tipas ‚Äî Patch Inline (UPDATED) -->
<script id="KOBLLUX_VOICES_INTEGRATION">
(()=>{
  const ARCHETYPES = [
    { id:'atlas',   name:'Atlas',   tone:'Estrat√©gico, met√≥dico',        modulation:'Grave, ritmo calculado, dic√ß√£o n√≠tida.',        voice:'Reed',    rate:1.0,  pitch:0.93 },
    { id:'nova',    name:'Nova',    tone:'Vibrante, entusiasmado',       modulation:'Agudo, entusiasmado, ligeiramente r√°pido.',      voice:'Luciana', rate:1.063, pitch:1.34 },
    { id:'vitalis', name:'Vitalis', tone:'Energ√©tico, urgente',          modulation:'R√°pido, intenso, motivacional.',                  voice:'Rocko',   rate:0.96, pitch:1.42 },
    { id:'pulse',   name:'Pulse',   tone:'Emocional, mel√≥dico',          modulation:'Fluido, tom m√©dio/suave.',                       voice:'Reed',    rate:1.0, pitch:1.14 },
    { id:'artemis', name:'Artemis', tone:'Aventureiro, expansivo',       modulation:'Curioso, explorat√≥rio.',                         voice:'es_f',    rate:1.00, pitch:1.23 },
    { id:'serena',  name:'Serena',  tone:'Calmo, acolhedor',             modulation:'Suave, terap√™utico, com pausas.',                voice:'Joana',   rate:0.92, pitch:0.90 },
    { id:'kaos',    name:'Kaos',    tone:'Desafiador, imprevis√≠vel',     modulation:'Intenso, ritmo entrecortado.',                   voice:'Rocko',   rate:1.09, pitch:1.28 },
    { id:'genus',   name:'Genus',   tone:'Pr√°tico, detalhista',          modulation:'Tom firme, foco na dic√ß√£o.',                     voice:'Reed',    rate:0.98, pitch:1.20 },
    { id:'lumine',  name:'Lumine',  tone:'Alegre, brincalh√£o',           modulation:'Agudo, vibrante.',                               voice:'Flo',     rate:1.030, pitch:1.55 },
    { id:'solus',   name:'Solus',   tone:'S√°bio, introspectivo',         modulation:'Grave, lento, eco sutil.',                       voice:'es_m',    rate:0.88, pitch:0.87 },
    { id:'rhea',    name:'Rhea',    tone:'Profundo, conectivo',          modulation:'Calmo, eco sutil.',                              voice:'Joana',   rate:1.02, pitch:0.59 },
    { id:'aion',    name:'Aion',    tone:'Futurista, met√≥dico',          modulation:'Tom constante, progressivo.',                    voice:'Monica',  rate:0.98, pitch:1.00 },

    { id:'kobllux', name:'KOBLLUX', tone:'N√∫cleo do sistema, oracular',
      modulation:'Grave-m√©dio, presen√ßa de comando, ritmo est√°vel.',     voice:'es_m',  rate:0.98, pitch:0.48 },

    { id:'uno',     name:'Uno',     tone:'Ess√™ncia, origem, foco',
      modulation:'Tom centrado, poucas varia√ß√µes, pausas marcadas.',     voice:'Grandma',    rate:0.90, pitch:0.93 },

    { id:'dual',    name:'Dual',    tone:'Espelho, contraste, jogo',
      modulation:'Alterna leve entre grave/agudo, ritmo pulsante.',      voice:'pt_m',    rate:1.02, pitch:1.02 },

    { id:'trinity', name:'Trinity', tone:'S√≠ntese, tr√≠ade viva',
      modulation:'Voz est√°vel com micro varia√ß√µes r√≠tmicas em 3 tempos.', voice:'Sandy', rate:1.04, pitch:1.04 },

    { id:'infodose',name:'Infodose',tone:'Did√°tico, carism√°tico, dopam√≠nico',
      modulation:'Tom amig√°vel, ritmo de recompensa ‚Üí curiosidade.',      voice:'Luciana', rate:1.06, pitch:0.96 },

    { id:'kodux',   name:'KODUX',   tone:'Criador do pulso, metaconsci√™ncia',
      modulation:'Grave, confiante, pausas longas, inten√ß√£o forte.',      voice:'Reed pt-BR',  rate:0.86, pitch:0.68 },

    { id:'bllue',   name:'Bllue',   tone:'Emocional, sensorial, intuitivo',
      modulation:'Suave, quase sussurrado, ritmo ondulante.',            voice:'Joana',   rate:0.94, pitch:1.42 },

    { id:'minuz',   name:'Minuz',   tone:'Minimalista, direto, hacker',
      modulation:'R√°pido, cortes secos, foco em termos t√©cnicos.',       voice:'Reed',    rate:1.05, pitch:0.90 },

    { id:'hanah', name:'HANAH', tone:'Est√©tico, simb√≥lico, futurista',
      modulation:'Tom limpo, levemente ecoado, cad√™ncia ritual√≠stica.',  voice:'Monica',  rate:1.00, pitch:1.08 },

  { id:'metalux', name:'MetaLux', tone:'Est√©tico, simb√≥lico, futurista',
      modulation:'Tom limpo, levemente ecoado, cad√™ncia ritual√≠stica.',  voice:'Grandma',  rate:0.80, pitch:1.68 }

  ];

  window.KOBLLUX_VOICES = ARCHETYPES.reduce((acc,a)=>{
    acc[a.name.toLowerCase()] = a;
    return acc;
  },{});

  const origSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);
  window.speechSynthesis.speak = (u)=>{
    const text = (u.text||'').toLowerCase();
    const found = ARCHETYPES.find(a=> text.includes(a.name.toLowerCase()));
    if(found){
      const voices = speechSynthesis.getVoices();
      const match = voices.find(v=> v && v.name && v.name.includes(found.voice));
      if(match) u.voice = match;
      u.pitch = found.pitch;
      u.rate  = found.rate;
      console.log('üéôÔ∏è KOBLLUX Voice ‚Üí', found.name, '‚Üí', found.voice, `(rate=${found.rate}, pitch=${found.pitch})`);
    }
    origSpeak(u);
  };

  console.log('‚ö° KOBLLUX Voices Integradas ‚Äî', ARCHETYPES.length, 'perfis ativos');

  // üîî avisa pro painel que as vozes est√£o prontas
  window.dispatchEvent(new Event('KOBLLUX_VOICES_READY'));

})();
</script>

<script id="KOB_VOICE_THEME_PATCH_V3">
(()=>{

  if (!('speechSynthesis' in window)) return;

  const root = document.documentElement;
  const body = document.body;
  const metaTheme = document.querySelector('meta[name="theme-color"]') || null;

  // Salva o tema neutro atual (INFODOXY) pra poder voltar depois
  const BASE = {};
  const VARS = ['--grad-a','--grad-b','--bg','--panel','--ink','--muted'];
  const cs = getComputedStyle(root);
  VARS.forEach(v=>{
    BASE[v] = cs.getPropertyValue(v) || '';
  });

  // Mapa de cores por arqu√©tipo (fallback).
  // Se voc√™ j√° tiver um window.KOB_VOICE_THEME em outro lugar,
  // ele √© mesclado por cima disso aqui.
  const DEFAULT_THEME = {
    neutral: {
      gradA: BASE['--grad-a'],
      gradB: BASE['--grad-b'],
      bg:    BASE['--bg'],
      panel: BASE['--panel'],
      ink:   BASE['--ink'],
      muted: BASE['--muted'],
      meta:  '#070b14'
    },

    atlas:   { gradA:'#00c4ff', gradB:'#0066ff', bg:'#050814', panel:'#0b1020', ink:'#eaf6ff', muted:'#8aa4c8', meta:'#04101f' },
    nova:    { gradA:'#ff7ad9', gradB:'#ffb347', bg:'#140512', panel:'#20091f', ink:'#ffeefc', muted:'#ffb7e4', meta:'#2a0723' },
    vitalis: { gradA:'#00ff95', gradB:'#00ffd0', bg:'#04140e', panel:'#071e17', ink:'#eafff7', muted:'#8fdac2', meta:'#012018' },
    pulse:   { gradA:'#ff5fa7', gradB:'#5f8bff', bg:'#120517', panel:'#1b0a22', ink:'#ffeafd', muted:'#c79ddc', meta:'#24082a' },
    serena:  { gradA:'#7bc7ff', gradB:'#7bffe0', bg:'#03111a', panel:'#071823', ink:'#eaf6ff', muted:'#99bfd7', meta:'#031520' },
    kaos:    { gradA:'#ff4b81', gradB:'#ffdd55', bg:'#18040a', panel:'#250811', ink:'#ffeef4', muted:'#ffb3c9', meta:'#24030b' },
    genus:   { gradA:'#9b8fff', gradB:'#5fffe3', bg:'#070718', panel:'#0c0d22', ink:'#eef0ff', muted:'#a4a8dd', meta:'#08081f' },
    lumine:  { gradA:'#ffe66b', gradB:'#ff9bff', bg:'#170a06', panel:'#25120e', ink:'#fff7e3', muted:'#f3cfa2', meta:'#261308' },
    solus:   { gradA:'#6b8cff', gradB:'#341f5f', bg:'#050715', panel:'#090b1f', ink:'#e3e8ff', muted:'#9ea4d6', meta:'#050716' },
    rhea:    { gradA:'#3cffd2', gradB:'#3c8bff', bg:'#031411', panel:'#071d19', ink:'#eafffb', muted:'#8cd8c8', meta:'#031914' },
    aion:    { gradA:'#9c7bff', gradB:'#4fd5ff', bg:'#060414', panel:'#0c0920', ink:'#f0e9ff', muted:'#b19de4', meta:'#07051a' },

    kobllux: { gradA:'#00ffd0', gradB:'#00b3ff', bg:'#020812', panel:'#050d18', ink:'#eafcff', muted:'#8ac7dd', meta:'#010710' },
    uno:     { gradA:'#ffffff', gradB:'#8ee7ff', bg:'#05070b', panel:'#090b11', ink:'#f5f8ff', muted:'#aeb4c8', meta:'#05070b' },
    dual:    { gradA:'#ff7ab3', gradB:'#7af0ff', bg:'#0b0510', panel:'#13081c', ink:'#ffeefe', muted:'#c49ccf', meta:'#0c0714' },
    trinity: { gradA:'#7affd1', gradB:'#ffef7a', bg:'#060b05', panel:'#0b1409', ink:'#f7ffef', muted:'#b7d7a9', meta:'#050c05' },

    infodose:{ gradA:'#00d8d8', gradB:'#d800d8', bg:'#050813', panel:'#090f1e', ink:'#f2f5ff', muted:'#a1a8c8', meta:'#060818' },
    kodux:   { gradA:'#00f5ff', gradB:'#0078ff', bg:'#02060f', panel:'#050a16', ink:'#e5f5ff', muted:'#8bb5d6', meta:'#020610' },
    bllue:   { gradA:'#6be1ff', gradB:'#3c6bff', bg:'#020911', panel:'#04121d', ink:'#e7f6ff', muted:'#8fbad3', meta:'#020b13' },
    minuz:   { gradA:'#b7b7b7', gradB:'#4b4b4b', bg:'#050505', panel:'#101010', ink:'#f3f3f3', muted:'#a5a5a5', meta:'#050505' },
    hanah:   { gradA:'#ffb3f8', gradB:'#70d7ff', bg:'#130514', panel:'#1c0b1e', ink:'#ffeefe', muted:'#c9a4d8', meta:'#160819' },
    metalux: { gradA:'#f5ff8a', gradB:'#8af5ff', bg:'#080b02', panel:'#101507', ink:'#f9ffe6', muted:'#c6d39b', meta:'#090d03' },

    // voc√™ pode usar esses dois via JS manualmente se quiser:
    cooplux: { gradA:'#ff9b6b', gradB:'#ffde6b', bg:'#120606', panel:'#1d0b0a', ink:'#fff4ea', muted:'#e5b7a1', meta:'#170807' },
    fitlux:  { gradA:'#7cffaf', gradB:'#7cbcff', bg:'#04140a', panel:'#071c11', ink:'#e9fff2', muted:'#9fd0aa', meta:'#04150c' }
  };

  const THEMES = Object.assign({}, DEFAULT_THEME, (window.KOB_VOICE_THEME || {}));

  function setVar(name, value){
    if (value != null && value !== '') {
      root.style.setProperty(name, value);
    }
  }

  function applyTheme(id){
    const key = (id && String(id).toLowerCase()) || 'neutral';
    const cfg = THEMES[key] || THEMES.neutral;
    setVar('--grad-a', cfg.gradA);
    setVar('--grad-b', cfg.gradB);
    setVar('--bg',     cfg.bg);
    setVar('--panel',  cfg.panel);
    setVar('--ink',    cfg.ink);
    setVar('--muted',  cfg.muted);
    if (metaTheme && cfg.meta) metaTheme.setAttribute('content', cfg.meta);

    if (key === 'neutral'){
      body.removeAttribute('data-voice-arch');
    } else {
      body.setAttribute('data-voice-arch', key);
    }
  }

  // Exposto pra voc√™ usar no console ou em outros patches
  window.KOB_APPLY_VOICE_THEME = applyTheme;

  // Detecta arqu√©tipo com base no texto + mapa de vozes atual
  function detectArchFromUtterance(u){
    const t = (u && u.text || '').toLowerCase();
    if (!t) return null;

    // se o bloco de vozes j√° estiver carregado, usa os nomes declarados l√°
    if (window.KOBLLUX_VOICES){
      for (const k in window.KOBLLUX_VOICES){
        if (!Object.prototype.hasOwnProperty.call(window.KOBLLUX_VOICES,k)) continue;
        const arch = window.KOBLLUX_VOICES[k];
        const name = String(arch.name || k).toLowerCase();
        // procura "[Atlas", "Atlas]" ou o nome puro
        if (t.includes('['+name) || t.includes(name+']') || t.includes(name+' ‚Äî') || t.includes('## '+name) || t.includes(name)){
          return (arch.id || name || k).toLowerCase();
        }
      }
    }

    // fallback: tenta pelas chaves do mapa de tema
    for (const k in THEMES){
      if (k === 'neutral') continue;
      if (t.includes(k.toLowerCase())) return k.toLowerCase();
    }

    return null;
  }

  // ==== override do speak, em cima do que J√Å existe ====
  const prevSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);
  const prevCancel = window.speechSynthesis.cancel.bind(window.speechSynthesis);

  window.speechSynthesis.speak = function(u){
    try{
      const archId = detectArchFromUtterance(u);
      if (archId){
        applyTheme(archId);
      } else {
        // se o texto n√£o tem arqu√©tipo expl√≠cito, mant√©m a √∫ltima cor
        // (se quiser neutro por padr√£o entre blocos, troca pra applyTheme(null); aqui)
      }
    }catch(e){
      console.warn('[KOB_VOICE_THEME_PATCH] erro ao detectar arqu√©tipo', e);
    }
    return prevSpeak(u);
  };

  window.speechSynthesis.cancel = function(){
    // quando parar tudo ‚Üí volta pro neutro
    try{ applyTheme(null); }catch{}
    return prevCancel();
  };

  // inicia neutro garantindo que o snapshot do tema base prevale√ßa
  applyTheme(null);

})();
</script>

<!-- KOBLLUX ¬∑ PATCH de Tema de Voz (cor por arqu√©tipo) -->
<script id="KOBLLUX_VOICE_THEME_PATCH">
(()=>{
  if (window.__KOBLLUX_VOICE_THEME_PATCH__) return;
  window.__KOBLLUX_VOICE_THEME_PATCH__ = true;

  const COLOR_MAP = {
    kobllux: {
      primary:'#00d8d8', secondary:'#d800d8', accent:'#39FFB6',
      bg_soft:'rgba(0,216,216,0.08)',
      glow:'0 0 18px rgba(0,216,216,0.55)'
    },
    cooplux:{
      primary:'#39FFB6', secondary:'#00d8d8', accent:'#ffffff',
      bg_soft:'rgba(57,255,182,0.10)',
      glow:'0 0 16px rgba(57,255,182,0.60)'
    },
    fitlux:{
      primary:'#FFC857', secondary:'#FFE39A', accent:'#22252f',
      bg_soft:'rgba(255,200,87,0.12)',
      glow:'0 0 16px rgba(255,200,87,0.70)'
    },
    atlas:{
      primary:'#6CCFF6', secondary:'#1B4965', accent:'#CAE9FF',
      bg_soft:'rgba(108,207,246,0.10)',
      glow:'0 0 14px rgba(108,207,246,0.55)'
    },
    nova:{
      primary:'#FF6FB5', secondary:'#FFD6E8', accent:'#FFE066',
      bg_soft:'rgba(255,111,181,0.12)',
      glow:'0 0 16px rgba(255,111,181,0.65)'
    },
    vitalis:{
      primary:'#00F5A0', secondary:'#00D9F5', accent:'#0b1720',
      bg_soft:'rgba(0,245,160,0.10)',
      glow:'0 0 18px rgba(0,245,160,0.65)'
    },
    pulse:{
      primary:'#A259FF', secondary:'#2D1B69', accent:'#F1E4FF',
      bg_soft:'rgba(162,89,255,0.12)',
      glow:'0 0 18px rgba(162,89,255,0.70)'
    },
    serena:{
      primary:'#7AD3A8', secondary:'#154734', accent:'#EAFBF3',
      bg_soft:'rgba(122,211,168,0.12)',
      glow:'0 0 16px rgba(122,211,168,0.65)'
    },
    kaos:{
      primary:'#FF5C8A', secondary:'#3D000F', accent:'#FFD6E0',
      bg_soft:'rgba(255,92,138,0.12)',
      glow:'0 0 20px rgba(255,92,138,0.75)'
    },
    genus:{
      primary:'#4EE1A0', secondary:'#193A3A', accent:'#E1FFF2',
      bg_soft:'rgba(78,225,160,0.10)',
      glow:'0 0 16px rgba(78,225,160,0.65)'
    },
    lumine:{
      primary:'#FFE066', secondary:'#FF9F1C', accent:'#2F2F40',
      bg_soft:'rgba(255,224,102,0.16)',
      glow:'0 0 18px rgba(255,224,102,0.75)'
    },
    rhea:{
      primary:'#00B894', secondary:'#055E55', accent:'#D1FFF6',
      bg_soft:'rgba(0,184,148,0.14)',
      glow:'0 0 16px rgba(0,184,148,0.65)'
    },
    solus:{
      primary:'#4B6584', secondary:'#0B1420', accent:'#E3EFFA',
      bg_soft:'rgba(75,101,132,0.16)',
      glow:'0 0 14px rgba(75,101,132,0.65)'
    },
    aion:{
      primary:'#00A8E8', secondary:'#001F54', accent:'#C4F1FF',
      bg_soft:'rgba(0,168,232,0.14)',
      glow:'0 0 16px rgba(0,168,232,0.70)'
    },
    uno:{
      primary:'#FFFFFF', secondary:'#BBBBBB', accent:'#FFFFFF',
      bg_soft:'rgba(255,255,255,0.05)',
      glow:'0 0 16px rgba(255,255,255,0.35)'
    },
    dual:{
      primary:'#FF9F1C', secondary:'#2EC4B6', accent:'#f5f5f5',
      bg_soft:'rgba(255,159,28,0.10)',
      glow:'0 0 14px rgba(255,159,28,0.65)'
    },
    trinity:{
      primary:'#00d8d8', secondary:'#FFE066', accent:'#ffffff',
      bg_soft:'rgba(0,216,216,0.09)',
      glow:'0 0 18px rgba(0,216,216,0.70)'
    },
    infodose:{
      primary:'#39FFB6', secondary:'#FFE066', accent:'#11141c',
      bg_soft:'rgba(57,255,182,0.12)',
      glow:'0 0 18px rgba(57,255,182,0.75)'
    },
    kodux:{
      primary:'#FF6FB5', secondary:'#5B2C6F', accent:'#FDEBFF',
      bg_soft:'rgba(91,44,111,0.18)',
      glow:'0 0 16px rgba(255,111,181,0.70)'
    },
    bllue:{
      primary:'#4A90E2', secondary:'#142850', accent:'#E3F2FF',
      bg_soft:'rgba(74,144,226,0.14)',
      glow:'0 0 16px rgba(74,144,226,0.70)'
    },
    minuz:{
      primary:'#FF3366', secondary:'#111111', accent:'#FFE3ED',
      bg_soft:'rgba(255,51,102,0.16)',
      glow:'0 0 16px rgba(255,51,102,0.75)'
    },
    hanah:{
      primary:'#FFB6C1', secondary:'#3C1F3C', accent:'#FFE9F0',
      bg_soft:'rgba(255,182,193,0.16)',
      glow:'0 0 16px rgba(255,182,193,0.70)'
    },
    metalux:{
      primary:'#B0E0E6', secondary:'#202733', accent:'#F0FBFF',
      bg_soft:'rgba(176,224,230,0.16)',
      glow:'0 0 18px rgba(176,224,230,0.70)'
    }
  };

  const root = document.documentElement;
  const body = document.body;

  function normalizeKey(s){
    return String(s||'').normalize('NFD')
      .replace(/\p{Diacritic}/gu,'')
      .toLowerCase()
      .replace(/[^a-z0-9]/g,'');
  }

  function detectArchKeyFromText(text){
    if(!text) return null;
    const raw = String(text);
    const trimmed = raw.trim();
    const lowAll  = trimmed.toLowerCase();

    // 1) [Nome] no come√ßo do par√°grafo
    const m = trimmed.match(/^\[([^\]]+)\]/);
    if(m){
      const namePart = m[1].split('‚Äî')[0].split('-')[0].trim();
      const k = normalizeKey(namePart);
      if(COLOR_MAP[k]) return k;
    }

    // 2) procura pelo nome dentro do texto
    for(const key of Object.keys(COLOR_MAP)){
      if(lowAll.includes(key)) return key;
    }

    // 3) fallback: hook externo (j√° existe no teu TTS)
    try{
      if(window.KOB_TTS_VOICE_STYLE_HOOK){
        const arch = window.KOB_TTS_VOICE_STYLE_HOOK(raw);
        const k = normalizeKey(arch);
        if(COLOR_MAP[k]) return k;
      }
    }catch(e){}

    return null;
  }

  function applyColorTheme(key){
    const cfg = COLOR_MAP[key];
    if(!cfg) return;

    root.style.setProperty('--kob-voice-primary',   cfg.primary  || '#00d8d8');
    root.style.setProperty('--kob-voice-secondary', cfg.secondary|| cfg.primary || '#d800d8');
    root.style.setProperty('--kob-voice-accent',    cfg.accent   || '#ffffff');
    root.style.setProperty('--kob-voice-bg-soft',   cfg.bg_soft  || 'rgba(0,0,0,0.25)');
    root.style.setProperty('--kob-voice-glow',      cfg.glow     || '0 0 0 transparent');

    if(body){
      body.setAttribute('data-voice-arch', key);
    }

    // se quiser integrar com outros pain√©is
    try{
      window.dispatchEvent(new CustomEvent('KOB_VOICE_COLOR',{
        detail:{ id:key, color:cfg }
      }));
    }catch(e){}
  }

  const prevSpeak = window.speechSynthesis.speak.bind(window.speechSynthesis);

  window.speechSynthesis.speak = function(u){
    try{
      if(u instanceof SpeechSynthesisUtterance){
        const key = detectArchKeyFromText(u.text||'');
        if(key){
          applyColorTheme(key);
          console.log('üé® KOBLLUX THEME ‚Üí', key);
        }
      }
    }catch(e){
      console.warn('KOBLLUX_VOICE_THEME_PATCH error:', e);
    }
    return prevSpeak(u);
  };

  console.log('‚ö° KOBLLUX_VOICE_THEME_PATCH ativo ‚Äî cores din√¢micas por arqu√©tipo');

})();
</script>

<!-- KOBLLUX ¬∑ Soft Transition Override (fade de cores) -->
<script id="KOB_THEME_TRANSITION_SOFT_OVERRIDE">
(()=>{
  if (window.__KOB_THEME_TRANSITION_SOFT_OVERRIDE__) return;
  window.__KOB_THEME_TRANSITION_SOFT_OVERRIDE__ = true;

  const css = `
  :root{
    /* dura√ß√£o padr√£o da transi√ß√£o de tema (pode ajustar aqui) */
    --kob-voice-theme-duration: 6600ms;
  }

  /* Tudo que costuma mudar de cor quando o tema troca */
  body,
  .nebula,
  .nebula-bg,
  .page,
  .page-inner,
  details.acc,
  .btn,
  #fab,
  .kob-tts-dock,
  .kob-tts-panel.is-dock {
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out,
      background        var(--kob-voice-theme-duration) ease-in-out,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out,
      border-color      var(--kob-voice-theme-duration) ease-in-out,
      color             var(--kob-voice-theme-duration) ease-in-out;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_THEME_TRANSITION_SOFT_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('üé® KOB_THEME_TRANSITION_SOFT_OVERRIDE ativo (fade ~1.1s)');
})();
</script>

<!-- KOBLLUX ¬∑ Soft Fade Extra para BACKGROUND -->
<script id="KOB_BG_FADE_OVERRIDE">
(()=>{
  if (window.__KOB_BG_FADE_OVERRIDE__) return;
  window.__KOB_BG_FADE_OVERRIDE__ = true;

  const css = `
  :root{
    --kob-voice-theme-duration: 7800ms;
  }

  /* Fade suave pro fundo principal e o glow nebuloso */
  body,
  .nebula{
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out !important,
      background        var(--kob-voice-theme-duration) ease-in-out !important,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out !important,
      color             var(--kob-voice-theme-duration) ease-in-out !important,
      filter            var(--kob-voice-theme-duration) ease-in-out !important;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_BG_FADE_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('üé® KOB_BG_FADE_OVERRIDE ativo (body + .nebula com fade ~1.2s)');
})();
</script>

<!-- KOBLLUX ¬∑ PATCH Buttons Fade + TTS Dock Soft Shadow -->
<script id="KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH">
(()=>{
  if (window.__KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH__) return;
  window.__KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH__ = true;

  const css = `
  :root{
    /* usa o mesmo timing do tema de voz, ou define aqui se quiser independente */
    --kob-voice-theme-duration: 1100ms;
  }

  /* Fades suaves para bot√µes, chips e afins */
  .btn,
  .chip,
  button,
  #fab,
  .fab,
  .menu button,
  details.acc,
  details.acc summary,
  .kob-tts-dock button,
  .kob-tts-panel.is-dock button{
    transition:
      background-color var(--kob-voice-theme-duration) ease-in-out,
      background        var(--kob-voice-theme-duration) ease-in-out,
      border-color      var(--kob-voice-theme-duration) ease-in-out,
      color             var(--kob-voice-theme-duration) ease-in-out,
      box-shadow        var(--kob-voice-theme-duration) ease-in-out;
  }

  /* Shadow mais discreto pro dock de TTS */
  .kob-tts-dock{
    box-shadow:
      0 6px 14px rgba(0,0,0,.30),
      inset 0 0 0 1px rgba(255,255,255,.04) !important;
  }
  `;

  const style = document.createElement('style');
  style.id = 'KOB_BUTTON_FADE_AND_TTS_SHADOW_CSS';
  style.textContent = css;
  document.head.appendChild(style);

  console.log('üé® KOB_BUTTON_FADE_AND_TTS_SHADOW_PATCH ativo (fade bot√µes + shadow TTS suave)');
})();
</script>
<script id="RTF_RENDER_INTEGRATION_V1">
(()=>{'use strict';

// ‚Äî heur√≠stica: checa se o conte√∫do parece RTF
function looksLikeRTF(text){
  if(!text) return false;
  const t = String(text).slice(0, 250);
  if(/^\s*{\\rtf1/i.test(t)) return true;
  if(/\\rtf1\\ansi/.test(t)) return true;
  const slashCount = (t.match(/\\/g) || []).length;
  if(slashCount > 12 && /\\(fonttbl|colortbl|viewkind|pard|stylesheet)\b/.test(t)) return true;
  return false;
}

// ‚Äî decoder simples RTF -> texto / Markdown cru
function decodeRTF(raw){
  if(!raw) return '';
  let txt = String(raw);

  // normaliza quebras de linha
  txt = txt.replace(/\r\n?/g, '\n');

  // \par, \pard, \line -> \n
  txt = txt.replace(/\\par[d]?\b/g, '\n')
           .replace(/\\line\b/g, '\n');

  // \'hh (hex) -> char
  txt = txt.replace(/\\'([0-9a-fA-F]{2})/g, (_,hex)=>{
    const code = parseInt(hex,16);
    return Number.isFinite(code) ? String.fromCharCode(code) : '';
  });

  // \uNNNN? -> unicode
  txt = txt.replace(/\\u(-?\d+)\??/g, (_,num)=>{
    let code = parseInt(num,10);
    if(!Number.isFinite(code)) return '';
    if(code < 0) code = 65536 + code; // corrige negativos comuns
    try{ return String.fromCharCode(code); }catch{ return ''; }
  });

  // remove outros comandos RTF (\palavra, \palavraN)
  txt = txt.replace(/\\[a-zA-Z]+-?\d*(?:\s)?/g, '');

  // remove chaves de grupo { }
  txt = txt.replace(/[{}]/g, '');

  // compacta linhas em branco
  txt = txt.replace(/\n{3,}/g, '\n\n');

  return txt.trim();
}

// ‚Äî wrap do autoBuild (flat)
if(typeof window.autoBuild === 'function'){
  const orig = window.autoBuild;
  window.autoBuild = function(text){
    let t = text;
    // se for RTF, decodifica antes de tudo
    if(looksLikeRTF(t)){
      try{
        const decoded = decodeRTF(t);
        // guarda o MD decodificado como ‚Äúestado atual‚Äù
        window.__current_md = decoded;
        t = decoded;
        window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
        window.toast && toast('RTF decodificado ‚Üí MD');
      }catch(e){
        console.warn('[RTF_RENDER] erro ao decodificar RTF', e);
      }
    }
    return orig(t);
  };
}

// ‚Äî wrap do autoBuildNested (aninhado)
if(typeof window.autoBuildNested === 'function'){
  const origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    let t = text;
    if(looksLikeRTF(t)){
      try{
        const decoded = decodeRTF(t);
        window.__current_md = decoded;
        t = decoded;
        window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
        window.toast && toast('RTF decodificado ‚Üí MD');
      }catch(e){
        console.warn('[RTF_RENDER] erro ao decodificar RTF (nested)', e);
      }
    }
    return origN(t);
  };
}

// ‚Äî helper global, se voc√™ quiser brincar via console: RTF_RENDER.decode(textoRTF)
window.RTF_RENDER = {
  looksLike: looksLikeRTF,
  decode: decodeRTF
};

})();
</script>

<!-- KOBLLUX ¬∑ ASCII Carousel v1 (marca ::anim ... ::end com ```ascii dentro) -->
<style>
  .ascii-anim{position:relative;display:block;margin:12px 0}
  .ascii-anim .ascii-frame{transition:opacity .25s ease}
  .ascii-anim .anim-ctrl{
    position:absolute;top:-10px;left:50%;transform:translate(-50%,-100%);
    padding:.4rem .7rem;border:1px solid var(--muted,#89a);
    background:rgba(0,0,0,.3);border-radius:999px;backdrop-filter:blur(4px)
  }
</style>
<script id="KOBLLUX_ASCII_ANIM_V1">
(()=>{'use strict';
function initAsciiCarousel(root=document){
  const marks=[...root.querySelectorAll('p')].filter(p=>p.textContent.trim().toLowerCase().startsWith('::anim'));
  for(const mark of marks){
    const cfg=mark.textContent.trim().slice(6).trim();
    const ms=(/(\d{2,5})/.exec(cfg)||[])[1]||1200;
    const frames=[];
    let n=mark.nextSibling;
    while(n && !(n.nodeType===1 && n.matches('p') && n.textContent.trim().toLowerCase()==='::end')){
      if(n.nodeType===1 && (n.matches('figure.ascii-card')||n.matches('pre[class*="language-ascii"],pre.language-text'))){
        frames.push(n);
      }
      n=n.nextSibling;
    }
    if(!frames.length) continue;
    const wrap=document.createElement('div');
    wrap.className='ascii-anim'; wrap.dataset.interval=ms;
    mark.replaceWith(wrap);
    frames.forEach(f=>wrap.appendChild(f));
    if(n && n.textContent.trim().toLowerCase()==='::end') n.remove();
    setupAnim(wrap, +ms);
  }
}
function setupAnim(wrap, ms){
  const frames=[...wrap.children];
  frames.forEach((el,i)=>{ el.style.display=i?'none':'block'; el.classList.add('ascii-frame'); });
  let i=0, playing=true, t=null;
  function step(){ if(!playing) return; frames[i].style.display='none'; i=(i+1)%frames.length; frames[i].style.display='block'; t=setTimeout(step, ms); }
  t=setTimeout(step, ms);
  const ctrl=document.createElement('button'); ctrl.className='anim-ctrl'; ctrl.textContent='‚è∏Ô∏é';
  ctrl.onclick=()=>{ playing=!playing; ctrl.textContent=playing?'‚è∏Ô∏é':'‚ñ∂Ô∏é'; if(playing){ t=setTimeout(step, ms);} else{ clearTimeout(t);} };
  wrap.prepend(ctrl);
}
document.addEventListener('DOMContentLoaded', ()=>initAsciiCarousel(document));
new MutationObserver(m=>m.forEach(x=>x.addedNodes&&x.addedNodes.forEach(n=>n.nodeType===1&&initAsciiCarousel(n))))
  .observe(document.body,{childList:true,subtree:true});
})();
</script>

<script id="RTF_RENDER_INTEGRATION_V1">
(()=>{'use strict';

// ===== Detectores =====
function looksLikeRTF(text){
  if(!text) return false;
  const t = String(text).slice(0, 250);
  if(/^\s*{\\rtf1/i.test(t)) return true;
  if(/\\rtf1\\ansi/.test(t)) return true;
  const slashCount = (t.match(/\\/g) || []).length;
  if(slashCount > 12 && /\\(fonttbl|colortbl|viewkind|pard|stylesheet)\b/.test(t)) return true;
  return false;
}

function looksLikeHTML(text){
  if(!text) return false;
  const t = String(text).slice(0, 400);
  if(/<!DOCTYPE html/i.test(t)) return true;
  if(/<html[\s>]/i.test(t)) return true;
  if(/<body[\s>]/i.test(t)) return true;
  // fallback: muitas tags de abertura
  const tagCount = (t.match(/<\w+/g)||[]).length;
  return tagCount > 5;
}

// ===== RTF ‚Üí texto =====
function decodeRTF(raw){
  if(!raw) return '';
  let txt = String(raw);

  txt = txt.replace(/\r\n?/g, '\n');
  txt = txt.replace(/\\par[d]?\b/g, '\n')
           .replace(/\\line\b/g, '\n');

  txt = txt.replace(/\\'([0-9a-fA-F]{2})/g, (_,hex)=>{
    const code = parseInt(hex,16);
    return Number.isFinite(code) ? String.fromCharCode(code) : '';
  });

  txt = txt.replace(/\\u(-?\d+)\??/g, (_,num)=>{
    let code = parseInt(num,10);
    if(!Number.isFinite(code)) return '';
    if(code < 0) code = 65536 + code;
    try{ return String.fromCharCode(code); }catch{ return ''; }
  });

  txt = txt.replace(/\\[a-zA-Z]+-?\d*(?:\s)?/g, '');
  txt = txt.replace(/[{}]/g, '');
  txt = txt.replace(/\n{3,}/g, '\n\n');

  return txt.trim();
}

// ===== HTML ‚Üí texto (estilo 78konvert) =====
function htmlToPlain(mdLike){
  let t = String(mdLike||'');
  // quebras b√°sicas
  t = t.replace(/<br\s*\/?>/gi, '\n')
       .replace(/<\/p>/gi, '\n\n')
       .replace(/<\/div>/gi, '\n')
       .replace(/<\/li>/gi, '\n');

  // listas
  t = t.replace(/<li[^>]*>/gi, '- ');
  // headings ‚Üí #
  t = t.replace(/<h1[^>]*>([\s\S]*?)<\/h1>/gi, (_m,g)=>'\n# '+g.trim()+'\n')
       .replace(/<h2[^>]*>([\s\S]*?)<\/h2>/gi, (_m,g)=>'\n## '+g.trim()+'\n')
       .replace(/<h3[^>]*>([\s\S]*?)<\/h3>/gi, (_m,g)=>'\n### '+g.trim()+'\n');

  // blockquote
  t = t.replace(/<blockquote[^>]*>([\s\S]*?)<\/blockquote>/gi, (_m,g)=>{
    const inner = g.replace(/<[^>]+>/g,'').trim();
    return inner ? '\n> '+inner+'\n' : '\n';
  });

  // remove qualquer outra tag
  t = t.replace(/<style[\s\S]*?<\/style>/gi, '')
       .replace(/<script[\s\S]*?<\/script>/gi, '')
       .replace(/<[^>]+>/g, '');

  // espa√ßos & entidades simples
  t = t.replace(/&nbsp;/g, ' ')
       .replace(/&amp;/g, '&')
       .replace(/&lt;/g, '<')
       .replace(/&gt;/g, '>')
       .replace(/&quot;/g, '"')
       .replace(/&#39;/g, "'");

  t = t.replace(/[ \t]+\n/g, '\n')
       .replace(/\n{3,}/g, '\n\n');

  return t.trim();
}

// ===== Wraps nos builders =====
function preprocessMaybe(text){
  let t = text;
  if(!t) return t;

  if(looksLikeRTF(t)){
    try{
      const decoded = decodeRTF(t);
      window.__current_md = decoded;
      window.__current_title = (decoded.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
      window.toast && toast('RTF decodificado ‚Üí MD');
      return decoded;
    }catch(e){
      console.warn('[RTF/HTML_RENDER] erro RTF', e);
      return t;
    }
  }

  if(looksLikeHTML(t)){
    try{
      const plain = htmlToPlain(t);
      window.__current_md = plain;
      window.__current_title = (plain.match(/^\s*#\s+(.+)$/m)||[])[1] || window.__current_title;
      window.toast && toast('HTML limpo ‚Üí texto');
      return plain;
    }catch(e){
      console.warn('[RTF/HTML_RENDER] erro HTML', e);
      return t;
    }
  }

  return t;
}

// autoBuild (flat)
if(typeof window.autoBuild === 'function'){
  const orig = window.autoBuild;
  window.autoBuild = function(text){
    const t = preprocessMaybe(text);
    return orig(t);
  };
}

// autoBuildNested (aninhado)
if(typeof window.autoBuildNested === 'function'){
  const origN = window.autoBuildNested;
  window.autoBuildNested = function(text){
    const t = preprocessMaybe(text);
    return origN(t);
  };
}

// helper global p/ brincar no console
window.RTF_RENDER = {
  looksLikeRTF,
  looksLikeHTML,
  decodeRTF,
  htmlToPlain
};

})();
</script>


<!-- KOBLLUX PATCH :: FAB auto-close on action click / outside click -->
<script id="KOB_PATCH_FAB_AUTOCLOSE">
(function(){
  const fab = document.getElementById('fab');
  const toggle = document.getElementById('fab-toggle');
  if(!fab || !toggle) return;
  // Close when clicking an action
  document.addEventListener('click', (e)=>{
    const a = e.target.closest('[data-action]');
    if (a && fab.classList.contains('open')) fab.classList.remove('open');
  });
  // Close when clicking outside
  document.addEventListener('click', (e)=>{
    const withinFab = e.target.closest('#fab');
    if (!withinFab && fab.classList.contains('open')) fab.classList.remove('open');
  }, true);
})();
</script>


<!-- KOBLLUX PATCH :: Converter (RTF‚ÜíMD, tabelista, tokens, buttons) -->
<script id="KOB_PATCH_CONVERTER">
function convertSourceToMD(raw){
  if (!raw) return '';
  // RTF ‚Üí texto b√°sico
  if (/^{\\rtf/i.test(raw)) {
    raw = raw
      .replace(/\\par[d]?/g, '\n')
      .replace(/\\tab/g, '\t')
      .replace(/\\'[0-9a-fA-F]{2}/g, ' ')      // escapes hex ‚Üí espa√ßo
      .replace(/\\[a-zA-Z]+\d*/g, '')          // comandos \b \i \fs...
      .replace(/[{}]/g, '')                    // remove braces do RTF
      .replace(/\n{2,}/g, '\n\n');
  }
  // normaliza√ß√µes
  let text = raw
    .replace(/[‚Äú‚Äù]/g,'"').replace(/[‚Äò‚Äô]/g,"'")
    .replace(/\r\n?/g, '\n')
    .trim();

  // TABELISTA (pula 1‚Äì2; 3 = header; 4 = <auto>; 5+ dados)
  text = text.replace(
    /(?:^|\n)#[^\n]*\n#[^\n]*\n\s*([\w\W]*?)\n\s*<auto>\n([\w\W]*?)(?=\n{2,}|$)/g,
    function(_, headerLine, dataBlock){
      const header = headerLine.split('|').map(s=>s.trim()).filter(Boolean);
      if (!header.length) return _;
      const sep = '|' + header.map(()=> '---').join('|') + '|';
      const rows = dataBlock.split('\n')
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#'))
        .map(l => {
          const cols = l.split('|').map(s=>s.trim());
          return '| ' + cols.join(' | ') + ' |';
        });
      return '\n| ' + header.join(' | ') + ' |\n' + sep + '\n' + rows.join('\n') + '\n';
    }
  );

  // bot√µes [[btn:acao|R√≥tulo]] ‚Üí HTML
  text = text.replace(/\[\[btn:([a-z0-9_-]+)(?:\|([^\]]+))?\]\]/gi,
    function(_,act,label){ return '<button class="btn action" data-action="'+act+'">'+(label||act)+'</button>'; });

  // tokens [voz:] [arch:] saneados (mantidos para o TTS parser)
  text = text.replace(/\[voz:\s*([^\]]+)\s*\]/gi, '[voz:$1]')
             .replace(/\[arch:\s*([^\]]+)\s*\]/gi, '[arch:$1]');

  // fences simples: fecha ``` se contar √≠mpar
  const fences = (text.match(/```/g)||[]).length;
  if (fences % 2 === 1) text += '\n```';

  return text;
}

// Bind converter button if present
document.addEventListener('click',(e)=>{
  const btn = e.target.closest('#btn-converter');
  if(!btn) return;
  const ta = document.getElementById('srcText');
  if(!ta) return;
  const md = convertSourceToMD(ta.value||'');
  ta.value = md;
  if (window.toast) toast('Convertido (RTF‚ÜíMD, tabelista, tokens, bot√µes)');
});
</script>

<!-- KOBLLUX PATCH :: FAB fecha logo ap√≥s clicar em uma a√ß√£o -->
<script>
(function(){
  const fab = document.getElementById('fab');
  if (!fab) return;

  fab.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-action]');
    if (!btn) return;

    // deixa a a√ß√£o rodar normal, e logo em seguida fecha o menu
    setTimeout(()=> {
      fab.classList.remove('open');
    }, 0);
  });
})();
</script>

<script id="FORCE_LUCIANA_ARQ_OVERRIDE_v4">
(()=> {
  if (window.__FORCE_LUCIANA_ARQ_OVERRIDE_V4__) return;
  window.__FORCE_LUCIANA_ARQ_OVERRIDE_V4__ = true;

  if (!('speechSynthesis' in window)) return;
  const synth = window.speechSynthesis;

  // ===== Utils b√°sicos =====
  const PT = v => /^pt/i.test(v.lang || '');
  const ES = v => /^es/i.test(v.lang || '');
  const NORM = s => String(s || '')
    .normalize('NFD').replace(/\p{Diacritic}/gu,'')
    .toLowerCase();

  function getVoicesSafe(){
    try { return synth.getVoices() || []; }
    catch { return []; }
  }

  // ===== Mapa de vozes por arqu√©tipo (pode sobrescrever via window.ARQ_VOICE_MAP) =====
  const VOICE_MAP = Object.assign({
    Atlas:   'pt_m',
    Nova:    'Luciana',
    Vitalis: 'Rocko',
    Pulse:   'es_m',
    Artemis: 'Monica',
    Serena:  'Joana',
    Kaos:    'Rocko',
    Genus:   'pt_m',
    Lumine:  'Monica',
    Solus:   'es_m',
    Rhea:    'Joana',
    Aion:    'Monica'
  }, (window.ARQ_VOICE_MAP || {}));

  // exp√µe pra voc√™ editar no console, se quiser:
  //   setArchetypeVoiceMap({ Atlas:'Monica', Nova:'pt_f' })
  window.ARQ_VOICE_MAP = VOICE_MAP;

  // Heur√≠sticas simples pros nomes t√≠picos (atalho, n√£o trava nada)
  const NAME_F_PT = /(luciana|vitor[ioa]|camila|maria|sofia|joana)/i;
  const NAME_M_PT = /(daniel|reed|ricardo|miguel|thiago|henrique|felipe|jo[a√£]o)/i;
  const NAME_F_ES = /(conchita|m[o√≥]nica|monica|paulina|luz)/i;
  const NAME_M_ES = /(jorge|fred|diego|sebasti[a√°]n|sebastian)/i;

  function pickBySpec(spec, vs){
    if (!spec) return null;
    const s = String(spec).trim().toLowerCase();

    // Tokens por idioma (pt_f, es_m, etc)
    if (s === 'pt_f') return vs.find(v => PT(v) && NAME_F_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'pt_m') return vs.find(v => PT(v) && NAME_M_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'es_f') return vs.find(v => ES(v) && NAME_F_ES.test(v.name || '')) || vs.find(ES) || null;
    if (s === 'es_m') return vs.find(v => ES(v) && NAME_M_ES.test(v.name || '')) || vs.find(ES) || null;

    // Idioma gen√©rico
    if (s === 'pt')   return vs.find(PT) || null;
    if (s === 'es')   return vs.find(ES) || null;

    // Nome direto ‚Üí parcial (ex: "Monica", "Luciana", "Reed")
    const exact = vs.find(v => NORM(v.name) === NORM(spec));
    if (exact) return exact;
    return vs.find(v => NORM(v.name).includes(NORM(spec))) || null;
  }

  // Detecta tag de arqu√©tipo no come√ßo do par√°grafo: [Atlas], [Nova], etc
  const ARCH_RE = /^\s*\[\s*([a-zA-Z0-9_]+)\s*\]/;

  function applyArchetypeVoice(u, vs){
    try{
      const m = (u.text || '').match(ARCH_RE);
      if (!m) return false; // sem tag [Atlas] / [Nova] etc

      const rawArch = m[1];
      const archKey = rawArch[0].toUpperCase() + rawArch.slice(1).toLowerCase();

      const spec = VOICE_MAP[archKey];
      if (!spec) return false;

      const v = pickBySpec(spec, vs);
      if (v){
        u.voice = v;
        // N√ÉO for√ßa idioma: s√≥ herda, se n√£o tiver nada definido
        if (!u.lang && v.lang) u.lang = v.lang;
        return true;
      }
      return false;
    }catch{
      return false;
    }
  }

  // ===== Fila + override leve do speak (sem Luciana/base for√ßada) =====
  const NATIVE_SPEAK  = window.__KOB_NATIVE_SPEAK__  || synth.speak.bind(synth);
  const NATIVE_CANCEL = window.__KOB_NATIVE_CANCEL__ || synth.cancel.bind(synth);
  window.__KOB_NATIVE_SPEAK__  = NATIVE_SPEAK;
  window.__KOB_NATIVE_CANCEL__ = NATIVE_CANCEL;

  let VOICES    = getVoicesSafe();
  let ready     = !!VOICES.length;
  const Q       = [];
  let polTimer  = null;
  let tries     = 0;

  function refreshVoices(){
    VOICES = getVoicesSafe();
    if (VOICES.length){
      ready = true;
      drainQueue();
      if (polTimer){ clearInterval(polTimer); polTimer = null; }
    }
  }

  function ensureVoices(){
    if (ready) return;
    if (typeof synth.onvoiceschanged === 'object'){
      synth.onvoiceschanged = refreshVoices;
    }
    if (!polTimer){
      polTimer = setInterval(()=>{
        tries++;
        refreshVoices();
        if (ready || tries > 40){
          clearInterval(polTimer);
          polTimer = null;
        }
      }, 150);
    }
  }

  function wireUtterance(u){
    try{
      if (u.__kob_wired_v4) return;
      u.__kob_wired_v4 = true;

      // S√≥ mexe se tiver tag de arqu√©tipo; se n√£o, deixa o TTS padr√£o decidir a voz
      applyArchetypeVoice(u, VOICES);
    }catch(e){
      console.warn('FORCE_LUCIANA_ARQ_OVERRIDE_v4 wireUtterance error', e);
    }
  }

  function drainQueue(){
    while(Q.length){
      const u = Q.shift();
      if (u.__kob_spoken_v4) continue;
      wireUtterance(u);
      u.__kob_spoken_v4 = true;
      NATIVE_SPEAK(u);
    }
  }

  synth.speak = function(u){
    if (!(u instanceof SpeechSynthesisUtterance)) return NATIVE_SPEAK(u);

    ensureVoices();
    if (!ready || !VOICES.length){
      Q.push(u);
      return;
    }

    wireUtterance(u);
    return NATIVE_SPEAK(u);
  };

  synth.cancel = function(){
    Q.length = 0;
    return NATIVE_CANCEL();
  };

  // prewarm leve
  refreshVoices();

  // helper opcional pra ajustar mapa via c√≥digo:
  window.setArchetypeVoiceMap = (m)=> Object.assign(VOICE_MAP, m || {});

})();
</script>

<!-- KOBLLUX ¬∑ PATCH Gatilhos de Arqu√©tipo (tags + frases) -->
<script id="KOB_TTS_ARCH_GATILHO_PATCH_V1">
(()=>{'use strict';
  if (!('speechSynthesis' in window)) {
    console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1: SpeechSynthesis n√£o dispon√≠vel.');
    return;
  }
  if (window.__KOB_TTS_ARCH_GATILHO_PATCH_V1__) return;
  window.__KOB_TTS_ARCH_GATILHO_PATCH_V1__ = true;

  const synth = window.speechSynthesis;
  const prevSpeak = synth.speak.bind(synth); // respeita patches anteriores

  // Mapa de vozes j√° existente (Atlas, Nova, etc)
  const VOICE_MAP = (window.ARQ_VOICE_MAP || {});
  const ARCH_KEYS = Object.keys(VOICE_MAP);
  if (!ARCH_KEYS.length){
    console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1: VOICE_MAP vazio, nada a fazer.');
  }

  // üîë Gatilhos de frase (voc√™ pode editar/expandir depois no console)
  const DEFAULT_TRIGGERS = {
    Atlas: [
      /\bupa[-\s]*atlas\b/i,
      /\bportal\s*\[\s*atlas\s*\]/i
    ],
    Nova: [
      /\bvia\s*\[\s*nova\s*\]/i,
      /\bmente nova\b/i
    ],
    Lumine: [
      /\blumine\b/i,
      /\barch[-\s]*lumine\b/i
    ]
    // adiciona mais se quiser‚Ä¶
  };

  // Mescla default + o que voc√™ definir manualmente:
  const TRIGGERS = Object.assign({}, DEFAULT_TRIGGERS, (window.ARQ_TRIGGERS || {}));
  window.ARQ_TRIGGERS = TRIGGERS; // exp√µe pra voc√™ brincar

  // Heur√≠sticas de idioma b√°sicas (pt/es)
  const PT    = v => /^pt\b/i.test(v.lang || '');
  const ES    = v => /^es\b/i.test(v.lang || '');

  const NORM = s => String(s || '')
    .normalize('NFD')
    .replace(/\p{Diacritic}/gu, '')
    .toLowerCase();

  function getVoicesSafe(){
    try { return synth.getVoices() || []; }
    catch { return []; }
  }

  function pickBySpec(spec, vs){
    if (!spec) return null;
    const s = String(spec).trim().toLowerCase();

    // Tokens por idioma (pt_f, es_m, etc)
    const NAME_F_PT = /(luciana|vitor[ioa]|camila|maria|sofia|joana)/i;
    const NAME_M_PT = /(daniel|reed|ricardo|miguel|thiago|henrique|felipe|jo[a√£]o)/i;
    const NAME_F_ES = /(conchita|m[o√≥]nica|monica|paulina|luz)/i;
    const NAME_M_ES = /(jorge|fred|diego|sebasti[a√°]n|sebastian)/i;

    if (s === 'pt_f') return vs.find(v => PT(v) && NAME_F_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'pt_m') return vs.find(v => PT(v) && NAME_M_PT.test(v.name || '')) || vs.find(PT) || null;
    if (s === 'es_f') return vs.find(v => ES(v) && NAME_F_ES.test(v.name || '')) || vs.find(ES) || null;
    if (s === 'es_m') return vs.find(v => ES(v) && NAME_M_ES.test(v.name || '')) || vs.find(ES) || null;

    if (s === 'pt')   return vs.find(PT) || null;
    if (s === 'es')   return vs.find(ES) || null;

    const exact = vs.find(v => NORM(v.name) === NORM(spec));
    if (exact) return exact;
    return vs.find(v => NORM(v.name).includes(NORM(spec))) || null;
  }

  // üéØ Detecta arqu√©tipo a partir de TODAS as formas de tag + frases de gatilho
  function detectArchetypeKey(text){
    if (!text || !ARCH_KEYS.length) return null;
    const raw   = String(text);
    const lower = raw.toLowerCase();

    for (const key of ARCH_KEYS){
      const n = key.toLowerCase();

      // [Atlas], [[Atlas]], (((Atlas))), {Atlas}, <Atlas>
      const bracket = new RegExp(`[\$begin:math:display$\\\\(\\\\{<]+\\\\s*${n}\\\\s*[\\$end:math:display$\\)\\}>]+`);
      if (bracket.test(lower)) return key;

      // Nome no in√≠cio com : ou tra√ßo ‚Äî ex: "Atlas: ..." ou "Nova ‚Äî ..."
      const header = new RegExp(`^\\s*${n}\\s*[:\\-‚Äì‚Äî¬∑>]`);
      if (header.test(lower)) return key;

      // Nome isolado entre espa√ßos com "modo tag" ex: "::Atlas::"
      const middle = new RegExp(`[\\s\\|:>\\-\\[]${n}[\\s\\|<\\-:!,.?]`);
      if (middle.test(lower)) return key;

      // Frases de gatilho custom
      const arr = TRIGGERS[key] || [];
      for (const rx of arr){
        try{
          if (rx.test(raw) || rx.test(lower)) return key;
        }catch(e){}
      }
    }
    return null;
  }

  // Opcional: remover tags de arqu√©tipo do texto falado (pra n√£o ler "[Atlas]" etc)
  function stripArchetypeTags(text, key){
    if (!text || !key) return text;
    const n = key.toLowerCase();

    // remove [Atlas], ((Atlas)), {{Atlas}}, <Atlas>, [[Atlas]] etc
    const genericBrackets = new RegExp(`[\\[\$begin:math:text$\\\\{<]+\\\\s*${n}\\\\s*[\\\\]\\$end:math:text$\\}>]+\\s*`, 'ig');
    let out = text.replace(genericBrackets, '');

    // remove "Atlas: " no come√ßo da linha
    const header = new RegExp(`^\\s*${n}\\s*[:\\-‚Äì‚Äî¬∑>]\\s*`, 'i');
    out = out.replace(header, '');

    return out.trim() || text;
  }

  synth.speak = function(u){
    try{
      if (u instanceof SpeechSynthesisUtterance && ARCH_KEYS.length){
        let text   = String(u.text || '');
        const arch = detectArchetypeKey(text);

        if (arch){
          const voices = getVoicesSafe();
          const spec   = VOICE_MAP[arch];
          const v      = spec ? pickBySpec(spec, voices) : null;

          if (v){
            u.voice = v;
            if (!u.lang && v.lang) u.lang = v.lang;
            // marca pra debug / painel
            u.__kob_arch = arch;
            // limpa as tags pra n√£o serem lidas
            u.text = stripArchetypeTags(text, arch);
            console.log('üéôÔ∏è ARCH_GATILHO', arch, '‚Üí', v.name, v.lang);
          }
        }
      }
    }catch(e){
      console.warn('KOB_TTS_ARCH_GATILHO_PATCH_V1 error', e);
    }
    return prevSpeak(u); // deixa LANG_SPEC, THEME etc trabalharem depois
  };

  console.log('‚ö° KOB_TTS_ARCH_GATILHO_PATCH_V1 ativo ‚Äî tags & gatilhos de arqu√©tipo liberados');
})();
</script>

<!-- KOBLLUX ¬∑ Bloquinho de Vozes + Gatilhos (Ion, Solus, Artemis, Pulse) -->
<script id="KOB_ARQ_BOOT">
  // üì£ Mapa de VOZ por arqu√©tipo
  // Esses valores entram em cima do VOICE_MAP padr√£o via Object.assign
  window.ARQ_VOICE_MAP = {
    // deixa Atlas/Nova no eixo padr√£o
    Atlas:   'pt_m',  // PT macho
    Nova:    'pt_f',  // PT feminina (Luciana / Joana / etc)

    // QUATRO QUE VOC√ä FALOU:
    Ion:     'es_m',  // espanhol macho
    Solus:   'es_m',  // espanhol macho
    Artemis: 'es_f',  // espanhol feminino
    Pulse:   'es_m',  // espanhol macho, ritmo

    // Se quiser for√ßar outros:
    // Lumine: 'pt_f',
    // Kaos:   'pt_m',
    // etc...
  };

  // üß† Tabelas de gatilhos de frase por arqu√©tipo
  // Lembrando: isso soma com DEFAULT_TRIGGERS dentro do patch
  window.ARQ_TRIGGERS = {
    Atlas: [
      /\bUPA-ATLAS\b/i,
      /\bPORTAL\s*\[\s*ATLAS\s*\]/i,
      'BASE ATLAS',
      'ATLAS NA BASE'
    ],
    Nova: [
      /\bMENTE NOVA\b/i,
      /\bTRINDADE\s+NOVA\b/i,
      'NOVA ARQUET√çPICA',
      'NOVA EM CENA'
    ],

    Aion: [
      'MODO ION',
      'ION EM CARGA',
      'IONIZAR O CAMPO',
      'ION FLUXO',
      'AI¬∑ON LIGADO' // A I ON üî•
    ],
    Solus: [
      'EIXO SOLUS',
      'SOLUS CENTRAL',
      'SOLUS NO COMANDO',
      'SOLUS EM √ìRBITA',
      'DECIS√ÉO SOLUS'
    ],
    Artemis: [
      'ALVO ARTEMIS',
      'MIRA ARTEMIS',
      'ARTEMIS EM CA√áA',
      'FOCO ARTEMIS',
      'RITUAL ARTEMIS'
    ],
    Pulse: [
      'PULSO ATIVO',
      'PULSE 3¬∑6¬∑9',
      'RITMO DO PULSE',
      'BPM DO PULSE',
      'PULSE NO BPM'
    ]
  };
</script>

<script>
/* KOBLLUX ¬∑ PATCH DE VOZ POR NOME
   - Usa o NOME da voz (v.name) para cada arqu√©tipo
   - Mant√©m fallback pro applyArchetypeVoice original se n√£o achar nada
   - Ajusta o nome Aion (nada de Ion kkk)
*/
(function () {
  if (typeof window === "undefined" || !("speechSynthesis" in window)) {
    return;
  }

  const synth = window.speechSynthesis;

  // üîä EDIT√ÅVEL: coloque aqui os nomes das vozes que voc√™ TEM no aparelho
  // Dica: use o painel de vozes que voc√™ j√° tem ou os nomes padr√£o tipo "Luciana", "M√¥nica", "Conchita", etc.
  const VOICE_NAME_PREFS = {
    Atlas:  ["Luciana", "pt-BR"],
    Nova:   ["Luciana", "pt-BR"],
    Vitalis:["Luciana", "pt-BR"],

    // Esses voc√™ queria em espanhol:
    Pulse:  ["M√≥nica", "Monica", "Conchita", "es"],
    Artemis:["M√≥nica", "Monica", "Conchita", "es"],
    Solus:  ["M√≥nica", "Monica", "Conchita", "es"],
    Aion:   ["M√≥nica", "Monica", "Conchita", "es"],

    Serena: ["Luciana", "pt-BR"],
    Kaos:   ["Luciana", "pt-BR"],
    Genus:  ["Luciana", "pt-BR"],
    Lumine: ["Luciana", "pt-BR"],
    Rhea:   ["Luciana", "pt-BR"],
    Horus:  ["Luciana", "pt-BR"]
  };

  // üß† Normaliza o nome (sem acento / caixa)
  function norm(str) {
    return String(str || "")
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
  }

  // Procura voz por nome / peda√ßo do nome / lang
  function pickVoiceByNamePrefs(archetype, voices) {
    const prefs = VOICE_NAME_PREFS[archetype];
    if (!prefs || !prefs.length) return null;

    const vlist = voices || synth.getVoices();
    if (!vlist || !vlist.length) return null;

    const normPrefs = prefs.map(norm);

    // 1) match exato de nome
    for (const p of normPrefs) {
      const exact = vlist.find(v => norm(v.name) === p);
      if (exact) return exact;
    }

    // 2) nome cont√©m o peda√ßo (ex: "Monica" dentro de "M√¥nica - es-MX")
    for (const p of normPrefs) {
      const byPart = vlist.find(v => norm(v.name).includes(p));
      if (byPart) return byPart;
    }

    // 3) se algum pref parece c√≥digo de idioma (ex: "es", "pt-br"), tenta lang
    for (const p of normPrefs) {
      if (p === "es" || p === "es-es" || p === "es-mx" || p === "pt-br" || p === "pt") {
        const byLang = vlist.find(v => norm(v.lang).startsWith(p));
        if (byLang) return byLang;
      }
    }

    return null;
  }

  // Guarda refer√™ncia do applyArchetypeVoice original, se existir
  const originalApply = window.applyArchetypeVoice || null;

  window.applyArchetypeVoice = function patchedApplyArchetypeVoice(utterance, archetypeName) {
    try {
      const voices = synth.getVoices();
      let arch = archetypeName;

      // Normaliza o nome do arqu√©tipo (Atlas, Nova, Pulse, Solus, Aion...)
      if (arch && typeof arch === "string") {
        arch = arch.trim();
        // Se vier em min√∫sculo, ajeita a primeira letra
        const low = arch.toLowerCase();
        const mapFix = {
          atlas: "Atlas",
          nova: "Nova",
          vitalis: "Vitalis",
          pulse: "Pulse",
          artemis: "Artemis",
          serena: "Serena",
          kaos: "Kaos",
          genus: "Genus",
          lumine: "Lumine",
          rhea: "Rhea",
          solus: "Solus",
          aion: "Aion",
          horus: "Horus"
        };
        arch = mapFix[low] || arch;
      }

      let chosen = null;

      if (arch && voices && voices.length) {
        chosen = pickVoiceByNamePrefs(arch, voices);
      }

      if (chosen) {
        utterance.voice = chosen;
        // marca no body quem t√° falando (pra tema / debug visual)
        try {
          document.body.dataset.voiceArch = norm(arch);
        } catch(e){/* ignora se der erro */ }
        return;
      }

      // Se n√£o achou nada pelas prefs, cai no comportamento antigo (se existir)
      if (typeof originalApply === "function") {
        originalApply(utterance, archetypeName);
      }

    } catch (err) {
      // Falhou o patch? volta pro original pra n√£o quebrar nada
      if (typeof originalApply === "function") {
        try { originalApply(utterance, archetypeName); } catch(e){}
      }
    }
  };

})();
</script>

</body></html>
